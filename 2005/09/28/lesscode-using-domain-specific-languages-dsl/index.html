<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head profile="http://gmpg.org/xfn/11">
	<meta http-equiv="Content-Type" 
        content="text/html; charset=UTF-8" />

  <title>  Lesscode using Domain Specific Languages (DSL)</title>
	<meta name="generator" content="WordPress 2.0.1" />

	<link rel="stylesheet" href="http://lesscode.org/wp-content/themes/almodovar/style.css" type="text/css" media="screen" />
	<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://lesscode.org/feed/" />
	<link rel="alternate" type="text/xml" title="RSS .92" href="http://lesscode.org/feed/rss/" />
	<link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="http://lesscode.org/feed/atom/" />
	<link rel="pingback" href="http://lesscode.org/xmlrpc.php" />

        <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
        </script>
        <script type="text/javascript">
        _uacct = "UA-125803-1";
        urchinTracker();
        </script>
		<link rel='archives' title='October 2006' href='http://lesscode.org/2006/10/' />
	<link rel='archives' title='April 2006' href='http://lesscode.org/2006/04/' />
	<link rel='archives' title='March 2006' href='http://lesscode.org/2006/03/' />
	<link rel='archives' title='January 2006' href='http://lesscode.org/2006/01/' />
	<link rel='archives' title='December 2005' href='http://lesscode.org/2005/12/' />
	<link rel='archives' title='November 2005' href='http://lesscode.org/2005/11/' />
	<link rel='archives' title='October 2005' href='http://lesscode.org/2005/10/' />
	<link rel='archives' title='September 2005' href='http://lesscode.org/2005/09/' />
	<link rel='archives' title='August 2005' href='http://lesscode.org/2005/08/' />
	<link rel='archives' title='July 2005' href='http://lesscode.org/2005/07/' />
	<link rel='archives' title='June 2005' href='http://lesscode.org/2005/06/' />
	<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://lesscode.org/xmlrpc.php?rsd" />
<script type="text/javascript">
/*-----AJAX-Comment-Preview-Variables-----*/
	var inputId     = 'comment';
	var outputId    = 'ajax-comment-preview';
	var doitId      = 'preview';
	var authorId    = 'author';
	var urlId       = 'url';
	var processURI  = '/wp-content/plugins/ajax-comment-preview.php';
	var emptyString = 'Click the "Preview" button to preview your comment here.';
/*----------------------------------------*/
</script>
<script type="text/javascript" src="/wp-content/plugins/ajax-comment-preview.js"></script>
</head>
<body>

<div id="page">
<h1><a href="http://lesscode.org">lesscode.org</a></h1>
<div id="navcontainer">
		<ul id="navlist">
			<li class="page_item"><a href="http://lesscode.org/archives/" title="archives">archives</a></li>
<li class="page_item"><a href="http://lesscode.org/about/" title="about lesscode.org">about lesscode.org</a></li>
		</ul>
</div>
<hr />

	<div id="content" class="narrowcolumn">

  
		<div class="navigation">
			<div class="alignleft">&laquo; <a href="http://lesscode.org/2005/09/28/lesscode-is-not-about-quantity/">Lesscode Is Not About Quantity</a></div>
			<div class="alignright"> <a href="http://lesscode.org/2005/09/29/should-database-manage-the-meaning/">Should Database Manage The Meaning?</a> &raquo;</div>
		</div>

		<div class="post">
			<h2 id="post-92"><a href="http://lesscode.org/2005/09/28/lesscode-using-domain-specific-languages-dsl/" rel="bookmark" title="Permanent Link: Lesscode using Domain Specific Languages (DSL)">Lesscode using Domain Specific Languages (DSL)</a>&nbsp;&nbsp;</h2>
			<small>By <a href="http://softwareindustrialization.com">Mitch Barnett</a>
      under <a href="http://lesscode.org/category/talk/" title="View all posts in Talk" rel="category tag">Talk</a> 
      on 28. September 2005</small>

			<div class="entrytext">
				<p>Having spent some time in the VS2005 environment, I can say the following about DSL’s:</p>

<p>A domain-specific language (DSL) is a language designed to be useful for a specific task in a fixed problem domain, in contrast to a general-purpose language.  DSLs are gaining popularity in the field of software engineering to enhance productivity, maintainability, and reusability of software artifacts, and enable expression and validation of concepts at the level of abstraction of the problem domain.</p>

<p>Using domain-specific languages, one can build customized modeling tools and essentially define a new modeling language and implement it very simply.  For example, a specialized language may be used to describe a user interface, a business process, a database, or the flow of information, and then used to generate code from those descriptions.</p>

<p>I built a (small) DSL for modeling application integration scenarios, which is always an issue in the IT business world.   First, I defined all of the specific domain model terms used in application integrations scenarios such as XML messages, source – destination applications, XSL maps, business units, protocols, business rules, etc.  Then I described the designer definitions that make up the visualization tool.  Once the meta data was defined in a supplied Visual Studio template, you build the solution and another instance of Visual Studio fires up with your visual designer implemented.</p>

<p>You then use the visual designer you just created to draw/model the application integration scenario and when you run this solution, it code generates the solution.</p>

<p>Of course, I have left out a lot of detail and it was not easy the first couple of times.  I have left out a set of code generators, which take a domain model definition and a designer definition as input, and produce code that implements both of the components as output.  The code generators also validate the domain model and designer definition, and raise errors and warnings accordingly.  But eventually, you get the hand of it.  </p>

<p>Think of it this way, DSL is a tool for building tools :-)  For example, anyone that has used the Class Designer in Visual Studio is using a DSL outputted visual designer, specifically designed for building classes.</p>

<p>The process has been quite the learning experience for me and has proven to be very enlightening.  I am an old guy, been writing code for 15 years.  Quite frankly, I don’t give a hoot about which programming language I use cause I see them all as being the same, some better than others, but still hand crafting code.  I don’t want to hand craft code anymore – every time I get involved in a software development project I a) have done it before and b) oh man, this is going to take 6 months of grinding it out.  In other words, it&#8217;s gonna hurt.</p>

<p>I see DSL’s as a evolution in our software industry to use higher level abstractions in the way of visual designers to so that I can spend time “designing” the solution and have most of the infrastructure code generated for me, that I otherwise would have to grind it out.</p>

<p>If anyone is interested in more information about DSL’s and don’t mind reading it from Microsoft, download the DSL Toolkit and have a read of the documents at: <a href="http://www.microsoft.com/downloads/details.aspx?FamilyId=57A14CC6-C084-48DD-B401-1845013BF834&amp;displaylang=en">Microsoft Domain-Specific Language (DSL) Tools</a></p>

				
        <a name="comments"> </a>
				<p class="postmetadata alter">
					<a href='http://lesscode.org/2005/09/28/lesscode-using-domain-specific-languages-dsl/feed/'>Comment <acronym title="Really Simple Syndication">RSS</acronym></a> -

													Both comments and pings are currently closed.

						
				</p>

			</div>
		</div>

	
<!-- You can start editing here. -->

	<h3 id="comments">16 Responses to &#8220;Lesscode using Domain Specific Languages (DSL)&#8221;</h3>

	<ol class="commentlist">
  	
		<li class="alt" id="comment-465">
			<p class="who"><cite><a href='http://ravimohan.blogspot.com' rel='external ' title='59.144.36.48'>Ravi Mohan</a></cite>:</p>
			<p>Excellent Post.</p>
<p>Most writing about DSL are very vague and not based on actual experience as yours is. That alone makes this a refreshing read. I have been using the same approach to build aMachine Learning Framework, and while optimizing the copiler is a little hairy the effort pays off handsomely.I am also a fairly &#8220;old guy&#8221; (10 years) and whle I belive that you need to be able to roll your own interprters/code generators before depening on tools to do so, I agree with your idea of DSLs as the next step.</p>
<p>Good writing.Keep this up!</p>
      <p>
			<small>comment at <a href="#comment-465" title="">29. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-470">
			<p class="who"><cite><a href='http://plasmasturm.org/' rel='external ' title='194.8.197.205'>Aristotle Pagaltzis</a></cite>:</p>
			<p>Strange. To me, DSLs are the antithet of code generation. To me, DSLs mean that the language is geared to the problem space so extensively that I can hand-write the solution to a task, directly, in the DSL. In other words, DSLs fall firmly on the &#8220;language maven&#8221; end of <a href="http://osteele.com/archives/2004/11/ides">the IDE divide</a>.</p>
<p>Either you have completely misunderstood something or I did.</p>
      <p>
			<small>comment at <a href="#comment-470" title="">29. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-471">
			<p class="who"><cite><a href='http://freepgs.com/akash' rel='external ' title='202.141.136.155'>akash</a></cite>:</p>
			<p>Do you know about Logix. A Meta language created in Python to create Domain Specific Languages. We had a presentation by the creator once.</p>
<p><a href="http://www.livelogix.net/logix/">http://www.livelogix.net/logix/</a></p>
<p>Thought you might like to check it out</p>
      <p>
			<small>comment at <a href="#comment-471" title="">29. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-473">
			<p class="who"><cite><a href='http://' rel='external ' title='198.73.138.2'>Alex Bunardzic</a></cite>:</p>
			<p>I&#8217;m afraid some of you may have misunderstood Mitch&#8217;s post. Of course, I don&#8217;t want to speak on his behalf, but being coworkers we get to spend time together talking about these things. And I think I happen to know where he is coming from, which is away from the code and towards the design. In other words, the focus is upwards, towards the human comunity, not downwards, towards the machinery.</p>
<p>I hope I got this right, as I don&#8217;t want to dillute Mitch&#8217;s message. If not, at least that&#8217;s my own personal orientation. And from this perspective, I agree with Mitch that it&#8217;s better to focus on the domain than on the infrastructure.</p>
      <p>
			<small>comment at <a href="#comment-473" title="">29. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-474">
			<p class="who"><cite><a href='http://www.emacswiki.org/alex/' rel='external ' title='217.162.112.104'>Alex Schroeder</a></cite>:</p>
			<p>Wasn&#8217;t Lisp all about writing applications as an implementation of a domain specific language?  In this respect I was quite surprised by the turn taken in the article.  I was expecting something about building an application bottom-up, writing code that gives you more more and more data- and control-structures, building the vocabulary to finally allow you to solve the problem on high-level terms.  If I take away the GUI part of the article, it could be about Lisp, I guess.</p>
      <p>
			<small>comment at <a href="#comment-474" title="">29. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-475">
			<p class="who"><cite><a href='http://naeblis.cx/rtomayko/' rel='external ' title='69.81.130.195'>Ryan Tomayko</a></cite>:</p>
			<p>I don&#8217;t subscribe to the GUI as DSL theory either. In fact, I think there&#8217;s a lot of places (especially in visual studio) where GUIs make bad substitutes for stronger language features. Aristotle hit it on the head for me when he said:</p>
<blockquote>
<p>DSLs fall firmly on the “language maven” end of the IDE divide.</p>
</blockquote>
<p>When I think of DSL, I think of Lisp, Rake, Rails, SQLObject, etc. not GUI wizards and code generators.</p>
      <p>
			<small>comment at <a href="#comment-475" title="">29. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-476">
			<p class="who"><cite><a href='http://blogger.nico-mommaerts.be' rel='external ' title='80.236.221.113'>Nico Mommaerts</a></cite>:</p>
			<p>Using visual tools and code generation seems to be the Microsoft way of using DSL&#8217;s. There are 2 kinds of DSL&#8217;s: embedded and layered. A classical example of this is Ant vs Rake. Ant was built by designing a new language (although using XML to avoid having to write a compiler/interpreter), Rake uses an existing language (Ruby). Anybody who has used Ant knows how frustrating and limiting it can be, you can&#8217;t fall back on another language, you are tied to the existing tasks or write new ones.  The same is true for visual DSL tools, although you have a highly specialized language at your disposal, if you want to do anything not foreseen by the tool, you are stuck or have to bend into all kinds of uncomfortable corners.</p>
<p>A colleague of mine suggested reading <a href="http://home.earthlink.net/~lbrodie/forth.html">Thinking Forth</a> as a way of learning about DSL&#8217;s.</p>
<p>My (few) links about DSL&#8217;s are <a href="http://del.icio.us/dfuse/dsl">here</a>.</p>
      <p>
			<small>comment at <a href="#comment-476" title="">29. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-477">
			<p class="who"><cite><a href='http://softwareindustrialization.com' rel='external ' title='198.73.138.2'>Mitch Barnett</a></cite>:</p>
			<p>Wow!  Interesting responses.  I certainly never figured myself as a language maven.  Maybe some context around why I wrote what I did about DSL’s.</p>
<p>My job is to solve business problems using IT where the requirements are generally very poor and there is little money or time to solve the business problem at hand.  Just part of the reality in my little business world I live in from a Systems Integrator perspective.  So to combat that, I try and find anything (beg, borrow or steal) that assists me in meeting unrealistic requirements and schedules.  This means a lot of incremental and iterative development to close the aforementioned gaps.</p>
<p>I look at DSL’s as just another tool in the toolbox to help me solve the business problem at hand.  As Alex has pointed out, my job is to design a solution to solve a business problem without having to write the same (or similar) plumbing or infrastructure code every time  So spending more time in the problem domain helps me do this.  Using DSL’s along with writing code, using 3rd party components and any other piece of design and/or code that I can reuse helps me solve the business problem.</p>
<p>Don’t get me wrong.  I live to code.  But business constraints of the real world force me to do (some) unnatural acts.  The application integration DSL I put together, albeit small, greatly assists me in meeting those business constraints, hence the reason why I use it – in addition to traditional coding (interface development), etc.  But when I can make a domain model/designer change in my DSL and have a solution delivered to my paying clients in fraction of the time it takes to traditionally code everything by hand, my clients really appreciate that and keep me employed.  I am just being pragmatic about the whole thing.</p>
<p>I also believe that, as in everything software, everyone has a different meaning and motivation to use the languages and tools we use.  Hopefully, with this little explanation some of that has come to light.</p>
      <p>
			<small>comment at <a href="#comment-477" title="">29. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-488">
			<p class="who"><cite><a href='http://plasmasturm.org/' rel='external ' title='194.8.197.205'>Aristotle Pagaltzis</a></cite>:</p>
			<p><a href="#comment-477">Mitch</a>: I see all that. The point is, using a wizards to generate code (even if the generator works on top of a model of the domain) still contradicts my understanding of DSLs.</p>
<p>In my mind, the entire point of a DSL is to be so abstract and high-level that you can write the code <em>by hand but without</em> writing any plumbing and infrastructure.</p>
<p>The canonical example of a language whose mentality is that you should do any task by creating a DSL of this type for the problem at hand and then using that DSL to solve it is Lisp, as <a href="#comment-474">Alex Schroeder points out</a>. The main tool towards that end are macros&#8212;which are far more powerful in Lisp than in any of the mainstream languages.</p>
<p>(FWIW, such macros are coming to Perl6.)</p>
      <p>
			<small>comment at <a href="#comment-488" title="">29. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-492">
			<p class="who"><cite><a href='http://softwareindustrialization.com' rel='external ' title='198.73.138.2'>Mitch Barnett</a></cite>:</p>
			<p>Aristotle - we definitely have a disconnect here.  Who said anything about wizards?  Let me state categorically that the DSL I am talking about is NOT wizard driven.  I ask that you take 10 minutes of your time to look at the link I provided to the documentation in the first post to look at how MS is doing DSL&#8217;s - we are talking about a &#8220;high fidelity&#8221; modeling environment - a visual designer that you drop domain specific objects onto a canvas to draw/model the solution, using a DSL visual designer.  Not wizards.  This is something completely different than what you think it is or at least from your post reply’s what I think you think it is :-)</p>
      <p>
			<small>comment at <a href="#comment-492" title="">29. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-495">
			<p class="who"><cite><a href='http://plasmasturm.org/' rel='external ' title='194.8.197.204'>Aristotle Pagaltzis</a></cite>:</p>
			<p>Sorry, sloppy terminology. I tend to lump all the IDE-style stuff together, my bad. Please re-read my comment with &#8220;GUI designers&#8221; substituted for &#8220;wizards;&#8221; the points remain the same ones.</p>
      <p>
			<small>comment at <a href="#comment-495" title="">30. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-497">
			<p class="who"><cite><a href='http://softwareindustrialization.com' rel='external ' title='198.73.138.2'>Mitch Barnett</a></cite>:</p>
			<p>Re: Aristotle and Alex S. - Sorry guys, I think you are missing the point entirely - DSL is NOT a programming language.  It is a higher level abstraction using a “meta model”, in this case a visual designer to &#8220;describe&#8221; what you want to build and then the &#8220;framework&#8221; generates code, and in MS case, it is either C# or VB.NET.  I am an old Smalltalk guy and I can tell you, this ain&#8217;t LISP - again, a DSL is NOT a programming language and that&#8217;s the whole point I am trying to make – obviously poorly.</p>
<p>Remember UML and class diagram&#8217;s where you could &#8220;draw&#8221; a class diagram hierarchy and Rational&#8217;s tool will build the code framework (ok stubs) for you?  Well, a DSL is a much more refined and higher level abstraction that allows you to &#8220;design&#8221; a specific language to solve a problem domain issue of interest - without hand crafting code.  That’s the point of a DSL.  Who care’s “how” it is done.  All I can tell you is that it would take me 10X longer to handcraft the code, compared to what I “designed” in the DSL to generate the code (more or less what I would have hand crafted in C# anyway) for me.  In other words, a DSL is simply a productivity tool that allows me to describe or define or model the solution, using meta data.  That’s it.  Simply another tool in the toolbox.  Nothing more, nothing less.</p>
      <p>
			<small>comment at <a href="#comment-497" title="">30. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-500">
			<p class="who"><cite><a href='http://naeblis.cx/rtomayko/' rel='external ' title='69.168.180.186'>Ryan Tomayko</a></cite>:</p>
			<p>Mitch said:</p>
<blockquote>
<p>I am an old Smalltalk guy and I can tell you, this ain’t LISP - again, a DSL is NOT a programming language and that’s the whole point I am trying to make – obviously poorly.</p>
</blockquote>
<p>I think the point was made aptly, there&#8217;s just some disagreement about your definition. For instance, <a href="http://www.martinfowler.com/bliki/DomainSpecificLanguage.html">Fowler describes DSLs</a> as follows:</p>
<blockquote>
<p>The basic idea of a domain specific language (DSL) is a computer language that&#8217;s targeted to a particular kind of problem, rather than a general purpose language that&#8217;s aimed at any kind of software problem. Domain specific languages have been talked about, and used for almost as long as computing has been done.</p>
</blockquote>
<p>He then points to Eric Raymond&#8217;s <a href="http://www.faqs.org/docs/artu/minilanguageschapter.html">Minilanguages</a> and Paul Graham&#8217;s <a href="http://www.paulgraham.com/progbot.html">Programming Bottom Up</a>, both of which describe using highly extensible languages (like Lisp) to craft new language features that serve a specific problem domain.</p>
<p>For more background, see <a href="http://homepages.cwi.nl/~arie/papers/dslbib/">Domain-Specific Languages: An annotated Bibliography</a>, which cites some 78  historical DSL texts. The definition of &#8220;DSL&#8221; put forth in that paper is as follows:</p>
<blockquote>
<p>A domain-specific language (DSL) is a programming language or executable specification language that offers, through appropriate notations and abstractions, expressive power focused on, and usually restricted to, a particular problem domain. </p>
</blockquote>
<p>To sum up, I don&#8217;t know what Microsoft is selling over there but it isn&#8217;t what the larger community has come to know as &#8220;Domain Specific Languages&#8221;. Perhaps a better term would be &#8220;Domain Specific Designer&#8221;.</p>
      <p>
			<small>comment at <a href="#comment-500" title="">30. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-505">
			<p class="who"><cite><a href='http://softwareindustrialization.com' rel='external ' title='198.73.138.2'>Mitch Barnett</a></cite>:</p>
			<p>Point taken Ryan (and Aristotle and Alex S.).  I had a look at the DSL definitions you supplied (and from others in this post) and understand why there might be different interpretations of the meaning of DSL.  Of course Microsoft, being who they are, always seems to do things “their way”.  Here is Microsoft’s view on the DSL tools they supply with Visual Studio”</p>
<p>“Using the Microsoft DSL tools you can create your own designer, integrated into Visual Studio, for a visual domain-specific language. The tools help you define the domain-specific language and generate the code of a graphical designer for you. The resulting designer uses the same underlying modeling technology that is used by the Class Designer and Distributed System Designers in Visual Studio 2005.”</p>
<p>In the end, I believe it complies with what a Domain Specific Language is, in its purest form, it’s just that Microsoft has a different way on “how” it achieves the end goal.  </p>
<p>Personally, I have been a fan of visualization tools, particularly from an architectural design perspective, because it raises the level of abstraction, much like how architectural blueprints are common practice in the “traditional” building design/construction world, using visualization tools like AutoCAD.  This is something we are still struggling with in the software development world – we don’t have a “standard” architectural blueprint that every programmer understands, from a semantic meaning perspective, and can build software that meets the specifications of the blueprint.  </p>
<p>This is what I mean by software industrialization – I certainly don’t mean making it a mechanized process, it will never become that way, but at the same time, every physical buildings architecture has been derived from an “architectural blueprint “where everyone involved in the construction process knows how to read it and more importantly, knows what it means.  From where I sit, we (still) don’t have anything like that is the software development world.  To me DSL’s are one step closer to this inevitable realization.</p>
      <p>
			<small>comment at <a href="#comment-505" title="">30. September 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-534">
			<p class="who"><cite><a href='http://www.emacswiki.org/alex/' rel='external ' title='212.243.143.100'>Alex Schroeder</a></cite>:</p>
			<p>I think the problem is that most developers have never seen both powerful visual programming environments and useful non-trivial building blocks.  If you have found both, more power to you!</p>
      <p>
			<small>comment at <a href="#comment-534" title="">05. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-768">
			<p class="who"><cite><a href='http://www.metacase.com/blogs/stevek/blogView' rel='external ' title='193.209.12.111'>Steven Kelly</a></cite>:</p>
			<blockquote>
<p>To sum up, I don&#8217;t know what Microsoft is selling over there but it isn’t what the larger community has come to know as &#8220;Domain Specific Languages&#8221;. Perhaps a better term would be &#8220;Domain Specific Designer&#8221;.</p>
</blockquote>
<p>Using &#8220;Designer&#8221; tends to put the focus on the tool; I think the equivalent term for the actually language should be &#8220;Domain-Specific Modeling Language&#8221;. I&#8217;ve also heard people talk about &#8220;textual DSLs&#8221; (which is fine) vs. &#8220;graphical DSLs&#8221;, but I&#8217;m not a fan of the latter term. In all the real industrial cases I can think of, the graphical format of the DSL does not show all the information contained in the model. To see the fine details of an object, you have to double-click its property dialog open or look at its property sheet. That&#8217;s an important advance over textual DSLs, which show all the detail. With a DSM Language the language designer chooses what is important enough to show all the time, and what can be hidden as details. He can also allow the modeler to make that decision for some elements (like most UML tools allow the modeler to show or hide the Attributes and Operations compartments of a UML Class symbol).</p>
<p>There was some discussion earlier about the difference between wizards, earlier code generators and <a href="http://www.metacase.com/blogs/stevek/blogView?showComments=true&amp;entry=3305839540">DSM with full code generation</a>. The main difference is whether you have to maintain what is generated, at the level of the generated code. Wizards and old-style code generators generally meant you had to do that: they produced lots of code quickly, but it was unfamiliar to you and you needed to maintain and probably extend it. With DSM, the code generated is the same as the code you wrote by hand before, and you don&#8217;t need to read or edit it. (See <a href="http://www.metacase.com/blogs/stevek/blogView?showComments=true&amp;entry=3289933398" title="Discovering simplicity">this blog entry</a> for more detail.)</p>
<p>And of course so as not to be accused of bias towards Microsoft, I ought to point out that they&#8217;re not the only people doing this :-). The <a href="http://www.dsmforum.org">DSM Forum</a> is the industry organization for all companies involved, and the web pages are a good starting point for information and links to further reading, real world cases and related events. In addition to Microsoft&#8217;s pre-release DSL tools there are also others that have a longer history in this area, including ourselves at <a href="http://www.metacase.com">MetaCase</a> with MetaEdit+, which has been used commercially for over ten years so is a tad more mature (if you&#8217;ll excuse the lack of modesty), and the Vanderbilt University GME research tool, which has also been around for years and is great for those who want to work on coding the next generation of such meta-tools.</p>
<p>If you want to play around with this to learn more, I think you&#8217;ll easily get furthest in a short time if you start with the MetaEdit+ 31-day <a href="http://www.metacase.com/fs.asp?paa=download/">evaluation version</a>: in an hour you can build your own first modeling language. If you prefer MS tools, you can try it out for 90 minutes on-line <a href="http://msdn.microsoft.com/vstudio/tryit/hosted/teamsystem/default.aspx" title="DSL Tools Virtual Lab">here</a> - installing it can be something of a long process, so that&#8217;s a good alternative.</p>
      <p>
			<small>comment at <a href="#comment-768" title="">29. November 2005</a> </small>
						</p>

		</li>

	
	        
	</ol>

 


	
	</div>


<div id="footer">
	<p style="float: left;">
		feeds: 
    <a href="http://lesscode.org/feed/atom/" title="Atom 0.3 feed for all posts">
      posts</a> (<a href="http://feedvalidator.org/check.cgi?url=http://lesscode.org/feed/atom/">valid?</a>)
    or <a href="http://lesscode.org/comments/feed/" title="RSS 2.0 feed for comments">comments</a>
       (<a href="http://feedvalidator.org/check.cgi?url=http://lesscode.org/comments/feed/">valid?</a>)
    <br />
		design by <a href="http://blog.ratterobert.com/">ratter / robert</a><br />
		powered by <a href="http://wordpress.org">WordPress</a>.<a href="http://wordpress.de">de</a><br />
	</p>
		<a name="search"><form method="get" id="searchform" action="/index.php">
<div><input type="text" value="" name="s" id="s" />
<input type="submit" id="searchsubmit" value="Search" />
</div>
</form>
</a>
</div>
<div id="switcher">
	<center>
			</center>
</div>
</div>
		</body>
</html>

<!-- Dynamic Page Served (once) in 0.390 seconds -->
<!-- Cached page served by WP-Cache -->
