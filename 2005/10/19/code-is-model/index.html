<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head profile="http://gmpg.org/xfn/11">
	<meta http-equiv="Content-Type" 
        content="text/html; charset=UTF-8" />

  <title>  Code is Model</title>
	<meta name="generator" content="WordPress 2.0.1" />

	<link rel="stylesheet" href="http://lesscode.org/wp-content/themes/almodovar/style.css" type="text/css" media="screen" />
	<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://lesscode.org/feed/" />
	<link rel="alternate" type="text/xml" title="RSS .92" href="http://lesscode.org/feed/rss/" />
	<link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="http://lesscode.org/feed/atom/" />
	<link rel="pingback" href="http://lesscode.org/xmlrpc.php" />

        <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
        </script>
        <script type="text/javascript">
        _uacct = "UA-125803-1";
        urchinTracker();
        </script>
		<link rel='archives' title='October 2006' href='http://lesscode.org/2006/10/' />
	<link rel='archives' title='April 2006' href='http://lesscode.org/2006/04/' />
	<link rel='archives' title='March 2006' href='http://lesscode.org/2006/03/' />
	<link rel='archives' title='January 2006' href='http://lesscode.org/2006/01/' />
	<link rel='archives' title='December 2005' href='http://lesscode.org/2005/12/' />
	<link rel='archives' title='November 2005' href='http://lesscode.org/2005/11/' />
	<link rel='archives' title='October 2005' href='http://lesscode.org/2005/10/' />
	<link rel='archives' title='September 2005' href='http://lesscode.org/2005/09/' />
	<link rel='archives' title='August 2005' href='http://lesscode.org/2005/08/' />
	<link rel='archives' title='July 2005' href='http://lesscode.org/2005/07/' />
	<link rel='archives' title='June 2005' href='http://lesscode.org/2005/06/' />
	<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://lesscode.org/xmlrpc.php?rsd" />
<script type="text/javascript">
/*-----AJAX-Comment-Preview-Variables-----*/
	var inputId     = 'comment';
	var outputId    = 'ajax-comment-preview';
	var doitId      = 'preview';
	var authorId    = 'author';
	var urlId       = 'url';
	var processURI  = '/wp-content/plugins/ajax-comment-preview.php';
	var emptyString = 'Click the "Preview" button to preview your comment here.';
/*----------------------------------------*/
</script>
<script type="text/javascript" src="/wp-content/plugins/ajax-comment-preview.js"></script>
</head>
<body>

<div id="page">
<h1><a href="http://lesscode.org">lesscode.org</a></h1>
<div id="navcontainer">
		<ul id="navlist">
			<li class="page_item"><a href="http://lesscode.org/archives/" title="archives">archives</a></li>
<li class="page_item"><a href="http://lesscode.org/about/" title="about lesscode.org">about lesscode.org</a></li>
		</ul>
</div>
<hr />

	<div id="content" class="narrowcolumn">

  
		<div class="navigation">
			<div class="alignleft">&laquo; <a href="http://lesscode.org/2005/10/11/little-help/">Little Help?</a></div>
			<div class="alignright"> <a href="http://lesscode.org/2005/10/20/ruby-rails-presentation/">Ruby, Rails and The Art of Software Development</a> &raquo;</div>
		</div>

		<div class="post">
			<h2 id="post-100"><a href="http://lesscode.org/2005/10/19/code-is-model/" rel="bookmark" title="Permanent Link: Code is Model">Code is Model</a>&nbsp;&nbsp;</h2>
			<small>By <a href="http://softwareindustrialization.com">Mitch Barnett</a>
      under <a href="http://lesscode.org/category/theory/" title="View all posts in Theory" rel="category tag">Theory</a> 
      on 19. October 2005</small>

			<div class="entrytext">
				<p>There is a great post by Harry Pierson over at his <a href="http://devhawk.net/CommentView,guid,7d6d6cb2-2300-4e39-8ad8-a2910d81d498.aspx">DevHawk blog site</a> describing  “what can we learn from looking at the success of mainstream text-based programming languages to help us in the development of higher abstraction modeling languages that are actually useful.”</p>

<p>As I have written elsewhere, I am a huge fan of <a href="http://softwareindustrialization.com/DisplayPost.aspx?PostID=17">raising the level of abstraction</a> to deal with complexity in our software world.  This is part of what I call the industrialization of software.  No, I don’t mean making programming fully automatic, as it will never be that way.  It is too large and complex to do so.  However, I am probably as frustrated as <a href="http://minimsft.blogspot.com/">Mini-Microsoft’s</a> quest to make Microsoft a leaner meaner machine in my quest to make software development more of a predictable and repeatable process.  It seemingly ain’t going to happen over night and may not happen in my lifetime!</p>

<p><a href="http://www.fourmilab.ch/autofile/www/chapter2_108.html#SECTION001080000000000000000">John Walker</a>, figured out the industrialization of the engineering design world when his invention, AutoCAD hit the market in 1982.  He said, “if you can’t model it, you can’t build it”.  Damn right!  In 2005 and in the software industry, we still have not figured it out, yet.  We are still bashing away with the stone age equivalent of hammers and chisels, whereas the engineering design world has AutoCAD to describe incredibly large and complex building structures, airplanes, engines, electronic circuit diagrams and just about everything else you can think of by modeling blueprints that are meaningful. People use these blueprints to turn models into real world constructs that you and I use every day.  How about that cell phone?  Or your iPOD? Or your car? Or that plane you just flew in on? Or <a href="http://softwareindustrialization.com/electricitytrain.htm">this</a>?</p>

<p>So what’s up with our software world?  Why do we refuse to adapt the successes of other industries, like the engineering design world, and leverage those successes in our software world?  What are we afraid of? Why are we stuck using (still) low level programming languages that we toil with at all hours of the day and night to produce inferior software products?  If we were designing and constructing commodity cars by hand and even fabricating the tools used to build the cars by hand, we would be laughed out of the industry.  How come software development seems to be different?  Where is our <a href="http://softwareindustrialization.com/DisplayPost.aspx?PostID=8">AutoCAD</a> for software development?</p>

<p>This may seem like a bit of a rant or maybe I have unrealistic expectations as to the maturity level of our software industry.  However, I still can’t believe, yours truly after being in the software development business for 15 years, still have to manually add an imports or using source code statement every time I add a reference to an assembly in Visual Studio.  What the ??  Not that I am picking on Visual Studio – I happen to think it is an excellent IDE along with introducing <a href="http://softwareindustrialization.com/DisplayPost.aspx?PostID=22">Software Factories</a>, <a href="http://softwareindustrialization.com/DisplayPost.aspx?PostID=38">Domain Specific Languages</a>, Guidance Automation Toolkits, etc.  While these tools and processes are definitely raising the level of abstraction in dealing with software complexity and advancing the industrialization of software, it still seems not enough to me.  We still lack standards like in the electronics design world for plug and play integrated circuits that I can order from a catalog. Or even standard electronic diagram symbols that describe everything electronic in which anyone trained in the industry can glean, in moments, what the circuit diagram is saying, with no ambiguity.  Are we there yet in our software world?</p>

<p>Moreover, we still have a world of programmers that refuse to even consider modeling as a first class software artifact – they consider it pretty pictures.  I know we have had issues in the past with CASE tools and with earlier versions of UML and other code generation tools.  But, I have software developers that I have worked with that won’t even give it a thought – they immediately get out their favorite source code editor and start writing code - so much for design.  And it seems the younger they are, the more I see this behavior or even the old school guys who have become “code crafters” where they take their craft extremely seriously and are totally affronted in the thought of using a “modeling” tool.  I am not sure I understand either group’s motivation for this behavior.  Where did it come from?  How come I (and a few others) don’t have this behavior?</p>

<p>What’s my point?  I don’t have one – I am just pondering, out loud, what it is going to take to bring the industrialization of software into reality – and how long?</p>

				
        <a name="comments"> </a>
				<p class="postmetadata alter">
					<a href='http://lesscode.org/2005/10/19/code-is-model/feed/'>Comment <acronym title="Really Simple Syndication">RSS</acronym></a> -

													<a href="http://lesscode.org/2005/10/19/code-is-model/trackback/">Trackback <acronym title="Uniform Resource Identifier">URI</acronym></a>

						
				</p>

			</div>
		</div>

	
<!-- You can start editing here. -->

	<h3 id="comments">27 Responses to &#8220;Code is Model&#8221;</h3>

	<ol class="commentlist">
  	
		<li class="alt" id="comment-608">
			<p class="who"><cite><a href='http://blog.labnotes.org' rel='external ' title='66.245.44.115'>assaf</a></cite>:</p>
			<p>It used to be that you would write the source code as a blueprint for what needs to be manufactured. And someone would use that source code to produce a piece of working code based on that blueprint.</p>
<p>Then we got rid of punch cards.</p>
<p>We&#8217;ve streamlined the whole production process, we took it down from hours to nanoseconds, with almost perfect reproduction quality. So the question is really, can we look at something other industries still call design, and turn that into production and streamline it.</p>
      <p>
			<small>comment at <a href="#comment-608" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-609">
			<p class="who"><cite><a href='http://www.jooto.com/blog/' rel='external ' title='198.73.138.2'>Alex Bunardzic</a></cite>:</p>
			<p>Good rant, and long overdue. I was thinking myself along the similar lines for some time now, and I must say that you hit the nail on the head. We <em>do need</em> to raise the level of abstraction, big time. There&#8217;s no two ways about it. However, I think that the AutoCAD-equivalent level would still be aiming too low. In other words, we need much higher abstractions than the software equivalent of the AutoCAD blueprints.</p>
<blockquote><p>So what’s up with our software world? Why do we refuse to adapt the successes of other industries, like the engineering design world, and leverage those successes in our software world? What are we afraid of? Why are we stuck using (still) low level programming languages that we toil with at all hours of the day and night to produce inferior software products? If we were designing and constructing commodity cars by hand and even fabricating the tools used to build the cars by hand, we would be laughed out of the industry. How come software development seems to be different? Where is our AutoCAD for software development?</p></blockquote>
<p>I think the issue here boils down to the subtle, or not so subtle differences between modeling and designing a software solution. Yes, if modeling is our final goal, I agree, AutoCAD paradigm fits in beautifuly. But the real challenges are, in my view, still in the world of designing a solution. Once the solution is designed properly, then there&#8217;s more than one way to skin a cat. And I fully agree with you that having the AutoCAD-equivalency models that would assist in predictability of the final product would be nice. Sort of what the previous commentator wrote about the punch cards. Punch cards were the AutoCAD prototypes in the software world. And they worked beautifully for the intended purposes.</p>
<p>But if the design is shoddy, no amount of AutoCAD compliance would ever be able to save our asses. And that&#8217;s where the real point of contention lies.</p>
<blockquote><p>However, I am probably as frustrated as Mini-Microsoft’s quest to make Microsoft a leaner meaner machine in my quest to make software development more of a predictable and repeatable process. It seemingly ain’t going to happen over night and may not happen in my lifetime!</p></blockquote>
<p>You are, again, right. It will be proven impossible to make the design process predictable and repeatable. We&#8217;re now slowly starting to discover that software design is actually more of an art than science, more of a craft than engineering. Again, no amount of AutoCAD compliance could help us there.</p>
<p>Unlike real life components (electric circuits, mechanical parts, patterns of fabric and so on), software components are not passive. They are not brain dead. They tend to <em>behave</em>. As such, they may not fit so obediently into the AutoCAD world.</p>
      <p>
			<small>comment at <a href="#comment-609" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-610">
			<p class="who"><cite><a href='http://www.livejournal.com/users/glyf' rel='external ' title='24.61.138.211'>Glyph Lefkowitz</a></cite>:</p>
			<p>Software addresses problems an order of magnitude more complex than engineering design; even the simplest program treats the hundreds of thousands of man-years that went into something as complex as a CPU too trivial to even bother having a representation for.  I&#8217;d say that&#8217;s a good indication that we&#8217;re doing something right.</p>
<p>The reason there is no &#8220;universal&#8221; notation is because different programming languages have <em>similar</em> concepts that mean <em>different</em> things, and for good reason.  It is therefore impossible to be equally precise.  A resistor is a resistor is a resistor, but a java.lang.Object is not a <strong>builtin</strong>.object is not a void* - what&#8217;s the physical analogue to automatic vs. manual garbage collection?</p>
<p>If you&#8217;re interested in improving the state of software, don&#8217;t do it with metaphors, do it with real techniques.  Do you have any <em>data</em> on software modeling to suggest it&#8217;s a good idea?</p>
<p>As a member of the younger generation of programmers you mention, I can explain my reaction to software modeling: I don&#8217;t believe it&#8217;s a first-class software artifact because <em>it&#8217;s not part of software</em>.  The process goes like this: you write some effectively meaningless diagrams that have only vague meaning to other people and no meaning whatsoever to the machine, then you go and mechanically translate that into code &#8212; except when the translation doesn&#8217;t work because current modeling techniques encourage sloppy thinking, and the model isn&#8217;t complete.  After all, if you knew what you were going to say in C++ you would have just written it in C++ in the first place, not drawn some boxes and lines!</p>
<p>I have seen software models written over and over and over again in my relatively brief tenure in the software industry, and every single time it has been a colossal waste of resources before the project, and if the models weren&#8217;t immediately destroyed, maintaining and updating them as the actual process of development pointed out their shortcomings was an even bigger chore.</p>
      <p>
			<small>comment at <a href="#comment-610" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-611">
			<p class="who"><cite>Anonymous</cite>:</p>
			<p>I think the problem with CASE, UML, et al. is that they all try to use pictures to represent a software model. Pictures may work well for architecture, engineering, and interior design, but they don&#8217;t work well for logic and algorithms. </p>
<p>Mathematics has been around for millennia. It has probably even been around longer than engineering. Yet, they still use a basically text-based format to describe their theorems and lemmas. Why haven&#8217;t they figured out a way to describe them using pictures yet? I&#8217;d wager that it&#8217;s because pictures to don&#8217;t work well for logic and algorithms.</p>
<p>So yes, we have created a fair number of abstractions; they just aren&#8217;t represented by pictures. To see how far we&#8217;ve come, consider that it&#8217;s much easier to deal with &#8220;Sets&#8221;, &#8220;Lists&#8221;, and &#8220;Maps&#8221;, than to deal with pointers into a memory array. It is far easier to deal with functions (sometimes even as first-class values), than to deal with GOTOs.</p>
<p>And yes, we aren&#8217;t at the end of the road yet. We can still continue to invent even more abstractions, just like mathematicians can.</p>
      <p>
			<small>comment at <a href="#comment-611" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-612">
			<p class="who"><cite><a href='http://www.emacswiki.org/alex/' rel='external ' title='217.162.112.104'>Alex Schroeder</a></cite>:</p>
			<p>Previous posters have essentially tried to demonstrate that software deals with problems that are more complex than engineering problems.  My explanation for this is that the physical world has physical constraints.  Gravity will always pull you down, and you can rely on that.  So there&#8217;s an aweful lot of tolerance that makes building roads easier, for example.  When implementing &#8220;roads&#8221; in software, you&#8217;re modelling out in the void: You&#8217;re building the road, the earth, the air, forces of nature such as gravity.  So yes, software allows us to build roads that float, explode, crash, disappear, etc.  All approaches to making things more predictable will involve adding constraints: Either you provide higher-level abstractions that are ready-to-use such as roads, planets, and gravity, or you go one step further and implement something akin to a virtual environment that provides higher-level abstractions with basic interactions predefined for you.  In a way, Ruby on Rails is one such solution.  Domain-specific game engines are another genre of such solutions.  With the level editor of game X, you can easily produce more variants of game X, but you can&#8217;t build webshop Y.  This is ok, you can&#8217;t take a road and build a car in real life, either.  The problem is that we have this relatively new thing called software, and we could build anything with it.  We have a hard time calling a level editor a higher-level programming tool.  We don&#8217;t like to call the configuration of a wiki the &#8220;programming&#8221; of a wiki.  Once we accept that such simple things are also &#8220;programming&#8221;, then I think that the riddle is solved: Any piece of software that can be adapted to different situations is in fact a domain-specific abstraction of &#8220;processing&#8221; that allows us to do &#8220;high-level programming&#8221;.  Usually we just don&#8217;t realize that programming and configuring and level-editing are different aspects of the same thing: Process modelling at different levels of abstraction.</p>
      <p>
			<small>comment at <a href="#comment-612" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-613">
			<p class="who"><cite><a href='http://beza1e1.tuxen.de' rel='external ' title='84.156.7.244'>beza1e1</a></cite>:</p>
			<p>I second that. Abstraction is possible today, but it is not done by UML. RSA is just math and there is no way you can model that with UML. UML is great for OOP architecturing, which is widely used.</p>
<p>I assume you speak of this kind of &#8220;industrial programming&#8221;, where dozens of Javaprogrammers are needed. I have no experience with such projects and i can&#8217;t think of reasons, why they should be that much harder to build.</p>
<p>This plug and play pieces are also possible today. I recently made a news feed aggregator. Getting the feed takes two lines.</p>
<p>import feedparser<br />
feed = feedparser.parse(url)</p>
<p>Mark Pilgrims Universal Feedparser is an excellent piece, which is instantly useable. I don&#8217;t know, what to expect further?</p>
      <p>
			<small>comment at <a href="#comment-613" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-614">
			<p class="who"><cite><a href='http://softwareindustrialization.com' rel='external ' title='198.73.138.2'>Mitch Barnett</a></cite>:</p>
			<p>Very interesting responses.  Thank you!</p>
<p>Glyph asked: </p>
<p>“If you’re interested in improving the state of software, don’t do it with metaphors, do it with real techniques. Do you have any data on software modeling to suggest it’s a good idea?”</p>
<p>Yes Glyph, I do have real data and not just someone else’s examples, which I could just list out here, but actual hands on, personal experience to suggest that modeling software for code generating solutions is not only a good idea, it’s real and it works! </p>
<p>In fact, a company called <a href="http://www.bridgewerx.com">Bridgewerx</a>  that I co-founded, has invented a product that code generates (actually it is a <a href="http://www.amazon.com/exec/obidos/tg/detail/-/0471202843/102-2577037-3549731?v=glance">software factory</a>) application integration solutions from a modeling tool.  It’s a real product from a real company based upon 4 years of developing application integration solutions by hand, which then took the patterns from these learning’s and reused them by embodying them into a modeling tool.</p>
<p>The modeling tool is a domain-specific language for describing application integration scenarios, which then produces an XML specification that our code generator then uses to assemble pre-built components (and some custom built components) and various other software artifacts (schemas, maps, assemblies, etc.) which then gets compiled and packaged as an installer which is then run on the target platform and installs the entire working application integration solution.</p>
<p>For the skeptics, try it out yourself, on-line at: <a href="http://www.bridgewerx.com/loading.htm?testdrive=true">http://www.bridgewerx.com/loading.htm?testdrive=true</a></p>
<p>Or if you don’t want to try it on-line but see actually how it works with a real live demo (no smoke and mirrors here guys), you can view this presentation that shows the actual bits behind the scenes and generating a real working application integration in 1 hour flat at:<br />
<a href="https://www119.livemeeting.com/cc/microsoft/view?id=857PK6&amp;pw=D2HNWT">https://www119.livemeeting.com/cc/microsoft/view?id=857PK6&amp;pw=D2HNWT</a></p>
<p>I know people have tried modeling tools or visual designers or whatever you want to call them before, with less than desirable results.  I was one of those people so frustrated with these tools, that I co-invented my own in the domain I was working in.</p>
<p>I will introduce you to the philosophy that drove my company to do this.  Sure it is from Microsoft, but who cares, it is the approach to modeling, DSL’s and software factories that help raise the level of abstraction for dealing with software complexity to is what’s useful and maybe, just maybe something that other people can learn from.</p>
<p><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnvs05/html/vstsmodel.asp">Visual Studio 2005 Team System Modeling Strategy and FAQ</a></p>
<p>Btw, I didn’t drink the kool-aid, but I do love Guinness :-)</p>
      <p>
			<small>comment at <a href="#comment-614" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-615">
			<p class="who"><cite>MThorn</cite>:</p>
			<p>The main reason why I often don&#8217;t model out my code before I code it is lack of sufficient tools to do so. I have yet to find software as useful as a plain whiteboard and marker.</p>
<p>I also don&#8217;t think it is important on modeling out how the project works. What is important is modeling out how the project will be used. Without seeing the big picture of how all your modules interact and are used, it&#8217;s hard to make the modules work together. Otherwise you end up with modules that are over engineered and can do way more than you really need to. Thus adding to complexity and wasting code time.</p>
<p>You should model the big picture, what does what, not how. Your code is the blueprint for how.</p>
      <p>
			<small>comment at <a href="#comment-615" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-616">
			<p class="who"><cite><a href='http://www.parand.com/say/' rel='external ' title='63.150.149.226'>Parand Tony Darugar</a></cite>:</p>
			<p>Oh oh. I like lesscode.org a lot, generally resonates with my own badly flawed brain, but now I hear a yearning for &#8230; UML? Code generation? </p>
<p>Hmm. Generated code is a horrible thing. Because eventually you have to debug that generated code, and sometimes even change it. Don&#8217;t generate code, create a higher level language. If you do generate code, it should be so deep under the covers I should have no way of getting to it even if I have a psychotic need to.</p>
<p>Domain specific language on the other hand is a reasonable thing.</p>
<p>UML is fine, does create <em>pretty pictures</em>, but doesn&#8217;t do much for me. I&#8217;ve found the best way to model software is to &#8230; write it. I&#8217;m not the young guy, and I&#8217;m not quite the old school guy either. I&#8217;m in no way opposed to anything that makes my coding life easier. The problem is, UML doesn&#8217;t actually make it any easier.</p>
<p>Perhaps the reason the two groups you mention haven&#8217;t embraced the tools you mention is because the tools don&#8217;t offer enough value yet. </p>
<p>The AutoCAD analogy doesn&#8217;t quite work for me either. In that world, AutoCAD is what you do. When you&#8217;re finished with the AutoCAD part of your work, you&#8217;re done with that task. You don&#8217;t have to pick up a second tool to make things actually work. UML, on the other hand, produces little other than decoration that you now have to go fill out.</p>
      <p>
			<small>comment at <a href="#comment-616" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-617">
			<p class="who"><cite>Dan Hatfield</cite>:</p>
			<p>+1 to the mathematics/logic comments - spot on!</p>
      <p>
			<small>comment at <a href="#comment-617" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-618">
			<p class="who"><cite><a href='http://advogato.org/person/mbrubeck/' rel='external ' title='207.171.180.101'>Dan Hatfield</a></cite>:</p>
			<p>Have you ever worked in an engineering discipline?  I went to an engineering school, and both my parents are architects.  I can tell you that CAD is a very small part of what it takes to create any building or physical device from scratch.  Before ever touching AutoCAD or other modeling tools, the engineer or architect will reach for a sketch book, or try building small-scale physical models or prototypes.</p>
<p>CAD is often just a tool to formalize and test the designer&#8217;s work, and turn it into instructions for manufacturing a final product.</p>
<p>In software, we don&#8217;t have this intermediate stage between creator and manufacturer.  Our medium is flexible enough that we can start by sketching or prototyping, and gradually transform our initial sketch into the final product.  When I &#8220;immediately get out my favorite source code editor&#8221;, I am an engineer reaching for a sketch book.</p>
      <p>
			<small>comment at <a href="#comment-618" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-619">
			<p class="who"><cite><a href='http://advogato.org/person/mbrubeck/' rel='external ' title='207.171.180.101'>Matt Brubeck</a></cite>:</p>
			<p>P.S. That last comment was by me (Matt Brubeck), not Dan Hatfield.  For some reason I ended up with Dan&#8217;s name in my comment form.</p>
      <p>
			<small>comment at <a href="#comment-619" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-620">
			<p class="who"><cite><a href='http://plasmasturm.org/' rel='external ' title='194.8.197.204'>Aristotle Pagaltzis</a></cite>:</p>
			<p><a href="#comment-616">Parand Tony Darugar</a>:</p>
<blockquote>
<p>If you do generate code, it should be so deep under the covers I should have no way of getting to it even if I have a psychotic need to.</p>
</blockquote>
<p>This is a reasonable stance, but experience shows that you can never bury the code generation deep enough.</p>
<p>We already have such code generators: compilers. And for the most part, you never fiddle with the generated code. But practice has shown that code generators alias compilers have bugs too; so in some rare cases, your perfectly correct code breaks because the machine code generator is broken. If, in that case, you really had no way of diving into the generated stuff, you would never be able to find out why what you wrote doesn&#8217;t work.</p>
<p>Joel Spolsky is right: you cannot afford to be ignorant about the lower layers. You can and should use abstractions to make your work faster, absolutely, but you cannot remain ignorant about the nitty gritty that is abstracted away for you.</p>
<p>Code generation is dangerous. It works for compilers because most of the time, you can spend <em>all</em> of your time above the abstraction layer. (Ie your code is all written in the high-level language.) If the abstraction is only partial, ie you were <em>expected</em> to write half your code in assembler and half in the high-level language, and compilers transmogrified the whole thing into an input for an assembler, there would be innumerably more problems.</p>
<p>But that is how modelling tools work.</p>
<p>Until you can create the entire program from start to finish within modelling tools, they will always be counterproductive. But then they&#8217;re no longer modelling tools anymore; they&#8217;d have become a programming environment of their own.</p>
<p>In other words, the entire premise of modelling is <abbr title="Broken As Designed">BAD</abbr>.</p>
      <p>
			<small>comment at <a href="#comment-620" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-621">
			<p class="who"><cite><a href='http://www.redmountainsw.com/wordpress' rel='external ' title='210.15.200.138'>Chui Tey</a></cite>:</p>
			<p>I doubt mechanical engineering is in any better state than software engineering. Want to know whether gears will fit well together or wear themelves out? Not much chance, unless you build the real one, or use an existing set. In software, you have static typing.</p>
<p>Want to know which part of your engine block will suffer the most stress? Finite element modelling comes to the rescue. In software, you have load testing tools.</p>
<p>What to know much load that part will bear? Only if you deal with known materials. In software, you use COTS components.</p>
<p>The lowest hanging fruit in software at the moment, is unified access to names and address database. If there is such a thing, most applications would already been halfway there.</p>
      <p>
			<small>comment at <a href="#comment-621" title="">19. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-622">
			<p class="who"><cite><a href='http://plasmasturm.org/' rel='external ' title='194.8.197.205'>Aristotle Pagaltzis</a></cite>:</p>
			<p>Another thing that just struck me is this quote from the original article:</p>
<blockquote>
<p>what can we learn from looking at the success of mainstream <b>text-based programming languages</b> to help us in the development of higher abstraction modeling languages that are actually useful. [<i>Bolding mine.</i>]</p>
</blockquote>
<p>Excuse me? These languages are &#8220;text-based&#8221; in the same way a UML tool is &#8220;line-and-arc-based.&#8221; The difference is the medium of communication: linguistic vs visual. To describe &#8220;linguistic&#8221; representation as &#8220;text-based&#8221; makes me wonder whether the author even understands the medium.</p>
<p>And I posit that graphical tools will never be very helpful at programming, although they can be very useful as configuration aids. Visual representation is awesome at conveying spatial relationships, but it is more hindrance than help at conveying temporal relationships&#8212;a programmer&#8217;s livelihood&#8212;, and completely incapable of expressing abstract concepts. There&#8217;s a reason only three-year-olds read picture books.</p>
<p>Among humans, the key to more efficient communication is jargon: an enlarged vocabulary that recognises common, complex concepts as distinct entities and names them, allowing those familiar with the jargon to communicate with fewer circumscriptions and thus decreased verbosity. A single sentence can then effortlessly convey as much meaning as would require a couple of pages of paper to express without the jargon.</p>
<p>Why would the key to increased efficiency in communicating with the machine be any different?</p>
<p>Indeed, is this not what Rails does? It gives the computer and the programmer a greater shared vocabulary, so the latter can communicate his intent to the former with <i>lesscode</i>. And look, you can build a simple but useful <abbr title="Create, Retrieve, Update, Delete">CRUD</abbr> application within a few hours, where it would take a week with less expressive systems. Less expressive: less shared jargon.</p>
<p>The key to <i>lesscode</i> is not <i>morecode-but-hey-it&#8217;s-generated-automatically</i>, it is <i>morejargon</i>.</p>
<p>(Overall, I have to say I am very disappointed with the direction the material on <code>lesscode.org</code> has been taking.)</p>
      <p>
			<small>comment at <a href="#comment-622" title="">20. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-623">
			<p class="who"><cite><a href='http://softwareindustrialization.com' rel='external ' title='216.86.98.252'>Mitch Barnett</a></cite>:</p>
			<p>Aristotle says he is disappointed.  I could not agree more.  I thought you guys were smart, but this discussion on modeling and code generation clearly shows me you don’t know what you speak of.</p>
<p>All I hear is everyone’s uneducated opinion and no facts.  Someone said code generation is just plain BAD.  Well, so is smoking, but so what!  Give me facts and real hands-on experience, not just your holier than thou opinions.  Honestly, I think I am dealing with a bunch of junior programmers infatuated with their text editors.  Show me you got brains and actual experience in this domain when you make your comment.</p>
<p>First let’s see if any of you are actually educated on the subject matter.</p>
<p>How many of you have read:<br />
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0201309777/103-5227914-6453460?v=glance">Generative Programming: Methods, Tools, and Applications</a></p>
<p>Or <a href="http://www.amazon.com/exec/obidos/tg/detail/-/1590591372/qid=1129802240/sr=1-1/ref=sr_1_1/103-5227914-6453460?v=glance&amp;s=books">Code Generation in Microsoft .NET</a></p>
<p>Or <a href="http://www.amazon.com/exec/obidos/tg/detail/-/1930110979/qid=1129802240/sr=1-2/ref=sr_1_2/103-5227914-6453460?v=glance&amp;s=books">Code Generation in Action</a></p>
<p>Or <a href="http://www.amazon.com/exec/obidos/tg/detail/-/0131425420/ref=cm_bg_d_4/103-5227914-6453460?v=glance">Eclipse Modeling Framework</a></p>
<p>Or <a href="http://www.amazon.com/exec/obidos/tg/detail/-/0471105600/ref=cm_bg_d_8/103-5227914-6453460?v=glance">Convergent Architecture: Building Model Driven J2EE Systems with UML</a></p>
<p>Or <a href="http://www.amazon.com/exec/obidos/tg/detail/-/0471319201/ref=cm_bg_d_11/103-5227914-6453460?v=glance">Model Driven Architecture: Applying MDA to Enterprise Computing</a></p>
<p>Or <a href="http://www.amazon.com/exec/obidos/tg/detail/-/0471202843/ref=pd_sr_ec_ir_b/103-5227914-6453460?v=glance&amp;s=books&amp;st=*">Software Factories: Assembling Applications with Patterns, Models, Frameworks, and Tools</a> </p>
<p>In fact there are 100’s of books on this subject matter.  I just listed the ones I have read so at least I can say I am somewhat educated as to what I am discussing.</p>
<p>Now to answer a few other questions.  Someone said software development is more complex than anything else.  So how long would it take for you to build a <a href="http://www.boeing.com/history/boeing/747.html">747</a> jet from scratch? Give your head a shake.</p>
<p>Someone said that mechanical engineering does not fair any better than software engineering.  Gentleman, our software delivery success rate is ABYSMAL.  Read some <a href="http://softwareindustrialization.com/DisplayPost.aspx?PostID=13">factual history</a> on the topic and give your head another shake.</p>
<p>Then there were several comments about AutoCAD.  How many of you have actually used AutoCAD or any CAD tool for that matter?  Did you know that CAD stands for Computer Assisted Design?  The keyword being design, which is what this entire discussion of modeling and code generation is about, but completely lost on all of you.  </p>
<p>Someone said that once you have done your AutoCAD you move onto something else.  Huh?  How do you think all of the engine components in your car that you all drive everyday got manufactured?  The output of virtually any CAD drawing usually goes into a Computer Numerical Control device (<a href="http://www.google.ca/search?hl=en&amp;lr=&amp;oi=defmore&amp;defl=en&amp;q=define:Computer+Numerical+Control">CNC</a>) which  mills out the piston you just designed in your modeling (CAD) tool.  Get the code generation analogy?</p>
<p>Finally, millions of software programmers have used a windows form designer tool to create windows forms.  The windows forms designer is nothing more than a domain specific language that generates code every time you drag and drop a UI widget onto the form canvas (just like AutoCAD).  I have yet to hear anyone (out of those millions of users) having the need to edit or modify the generated code over the last several years these tools have been in use.  Why do some of you think that you need to modify the generated code?  I smell FUD!</p>
<p>What does this all mean?  It proves the points I was making in my original post – most developers, for what ever reason (give me some real factual and experiential reasons guys, not your uneducated hearsay) would not touch code generation with a ten foot pole.  All of your posts have proved me correct. </p>
<p>I thought lesscode was indeed about writing less code and focusing more on real-world design issues using modeling tools and code generation to automate the rote tasks that we do on a daily basis.  Or how about the use of design patterns and frameworks that were discovered and built by someone other than you.  Lesscode, eh?  It appears not.</p>
      <p>
			<small>comment at <a href="#comment-623" title="">20. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-624">
			<p class="who"><cite>Zero Zero</cite>:</p>
			<p>This is incredible nonsense, Mitch. Go plug your company someplace else. This piece so misses the point of &#8220;lesscode&#8221; it borders on trolling.</p>
      <p>
			<small>comment at <a href="#comment-624" title="">20. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-625">
			<p class="who"><cite><a href='http://www.parand.com/say/' rel='external ' title='216.52.229.254'>Parand Tony Darugar</a></cite>:</p>
			<blockquote>
<p>All I hear is everyone’s uneducated opinion and no facts. Someone said code generation is just plain BAD. Well, so is smoking, but so what! Give me facts and real hands-on experience, not just your holier than thou opinions.</p>
</blockquote>
<p>I believe that&#8217;s a crack at me? For what it&#8217;s worth, I&#8217;ve written 3 compilers in my life. I&#8217;ve done a fair bit of code generation. I&#8217;d recommend against code generation from hands-on experience. I&#8217;ve also created a couple of higher level languages. Not so bad there. I also created a commercial product that allowed visual programming. Neat, very useful for specific domains, but ultimately pretty limited.</p>
<p>And I&#8217;m spreading FUD because I have a company or product to shill here&#8230; Oh wait, I don&#8217;t. Hmm.</p>
<p>Any case, very entertaining thread.</p>
<p>My point is simply that I&#8217;ve never found UML useful other than for communicating high level design across teams. I am certainly no UML expert - barely a beginner in fact. If there are better tools, I&#8217;m all for it, but I haven&#8217;t heard anything here that sounds like a solution.</p>
      <p>
			<small>comment at <a href="#comment-625" title="">20. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-626">
			<p class="who"><cite><a href='http://softwareindustrialization.com' rel='external ' title='198.73.138.2'>Mitch Barnett</a></cite>:</p>
			<p>Parand - I am certainly not taking cracks at anyone, however, I can&#8217;t say the same for myself.</p>
<p>For the record, I am not flogging any product here.  Glyph asked specifically if I had any data to support the notion of modeling and code generation is a good idea - rather then quote some scriptures, I would rather use a personal real world example - which I did share and which people took as flogging a product.  I don&#8217;t work for that company anymore and nor do I get any financial benefit from product sales.  The point is that I believe that modeling (using DSL’s specifically or generically called model-driven development) can be used for more than just pretty pictures.   The many references to several commercially available DSL’s, code generators and extensive reference books out there support this belief.  However, I am not a proponent of UML for modeling code for generation.</p>
<p>Even if you do vehemently disagree with some else’s postulations, at least have the common courtesy to back up your comments with some actual facts and/or personal experience.  Parand, I thank you for at least saying that you have had some actual experience with the domain subject, but wish you could be more specific in why you would say stay away from code generation, from hands on experience.  So what was that experience?  That’s what I was hoping to hear and learn from my peers on this forum.</p>
<p>It says in the about box that “lesscode.org is a place to advocate, discuss, and practice the art of using less code to get more done. We shun complexity and challenge the status-quo when it impedes our ability to simplify our development tools and processes.”  That’s what my original post was about. </p>
      <p>
			<small>comment at <a href="#comment-626" title="">20. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-628">
			<p class="who"><cite><a href='http://www.parand.com/say/' rel='external ' title='216.52.229.254'>Parand Tony Darugar</a></cite>:</p>
			<p>Dear Mitch,</p>
<blockquote>
<p>wish you could be more specific in why you would say stay away from code generation, from hands on experience.</p>
</blockquote>
<p>Fair enough. My experience with code generation has been:</p>
<p>1 - Generated code is skeleton and needs to be modified<br />
2 - Generated code is intended to be complete, doesn&#8217;t need modification</p>
<p>In the case of 1, I&#8217;ve found the generation of skeleton is generally not very useful. Typically the skeleton is just laborious decoration, symptom of a highly verbose language (J2EE comes to mind). My preference would then be to use a higher level language.</p>
<p>In the case of 2, I&#8217;ve found the tools either buggy, or not capable enough and the generated code in need of extension / modification. Bugs in generated code is an absolute nightmare, should never happen, but has happened frequently for me (SWIG being the only notable exception, although that has its hiccups too). Extending the generated code is also a nightmare, because you typically lose the ability to go back to the tool that you generated the code from.</p>
<p>Basically I&#8217;m saying that unlike scripting languages, the code generation mechanism typically doesn&#8217;t have a way of creating extensions (tieing in c/c++ code). That turns out to be very painful.</p>
<p>Any case, I invariably end up with my hands in the generated code, cursing and crying.</p>
      <p>
			<small>comment at <a href="#comment-628" title="">20. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-631">
			<p class="who"><cite><a href='http://naeblis.cx/rtomayko/' rel='external ' title='69.168.180.186'>Ryan Tomayko</a></cite>:</p>
			<p>Mitch, I think you&#8217;re making a bad assumption about what most programmers that read this site are after. I personally don&#8217;t have anything against visual designers, modeling tools, IDEs, etc. when they&#8217;re used where they make sense. For instance, window/GUI design tools that let you drop widgets on a canvas, arranging things just so, toggle visible configuration, etc. make perfect sense. You&#8217;re designing something visible and a graphical tool can assist in that. Some may generate horrible code but that&#8217;s something that can be improved. Modeling tools that let me describe a process so that I might use it as an illustration to better explain something to another person are also valuable. When working with Java, C#, VB.NET, C++, and other languages that lack expressiveness, graphical tools for managing the mess of code you accumulate are also often valuable.</p>
<p>But text based programming languages are prolific for a reason and I&#8217;ve seen nothing (even after reading the portions of material you&#8217;ve provided that I can find online) that suggests that is going to change any time soon. Text is simple, malleable, robust. It offers a common interface and set of interaction techniques regardless of domain/vocabulary. Don&#8217;t underestimate the value in that. Text is not a problem we need to solve, it is an amazing example of the power of simplicity and the advantages of systems that follow the principle of least power. If people who have been programming for a long time have grown an attachment to text it is not due to lack of value.</p>
<p>When I say I want to &#8220;raise the level of abstraction&#8221; and reduce code, I&#8217;m not saying I want to get rid of text. I don&#8217;t see text as being the problem. I&#8217;m saying I want a more expressive language that doesn&#8217;t require needless syntax or GUI wizards to accomplish the simplest of tasks. I want to be able to express my intent quickly and cleanly, preferably without leaving the language. If I must leave the language in order to express something, it is a deficiency of the language. If there is something I cannot express quickly or cleanly, I should be able to build libraries or build up the language directly (i.e. DSLs) so that I <em>can</em> express something quickly and cleanly. There are languages that allow these types of activities (Ruby, Python, Lisp, Smalltalk, etc.) and those that do not (Java, VB.NET, C#, etc.). The latter tend to grow a large crop of static code generators, GUI wizards, and language manipulating IDE features. The former do not. The reason isn&#8217;t because people using Ruby or Python are junior programmers incapable of understanding the features these tools provide, it&#8217;s because their languages are sufficiently powerful to not require them. You are assuming that because C#, VB.NET, and Java require additional apparatus to reduce code and keep the programmer productive that all languages do. That just isn&#8217;t so.</p>
<p>The feeling I get is that your issue is with programmers who refuse to consider graphical tools where they make sense; that&#8217;s completely understandable. Saying that all graphical tools are worthless is something you&#8217;re likely to hear only out of the greenest wannabe unix hacker trying to be cool. Ignore them and move along. But you seem to be taking the opposite position - that text is some kind of legacy technology and that we should be trying to do everything graphically without stopping to consider that many people don&#8217;t subscribe to that line of thinking. Text is amazingly powerful. I, and from the looks of things few of the people that read lesscode.org, are in any hurry to be rid of it.</p>
<p>I&#8217;m not sure how else to say it, this just isn&#8217;t what we&#8217;re talking about here. We&#8217;re using simple, proven technologies (text, the web), dynamic languages, and very old techniques that have been around since the dawn of computing to get real shit done right now. We&#8217;re not trying to figure out new and revolutionary methods of writing programs because we&#8217;ve been down that path and been sold that story 100 times before and its never worked out. What has worked is small and simple improvements to existing tools that are already working. This isn&#8217;t a conclusion you come to through lack of experience, it&#8217;s the conclusion you come to having been beat up by experience. </p>
<p>Lastly, I have to ask that you consider the responses you&#8217;re receiving from the regular readers of this site with respect and not respond with such hostility when they take the time to leave their thoughts on what you&#8217;ve presented. I don&#8217;t mind you posting stuff that&#8217;s a bit different because I think the discussion that follows can be healthy but I won&#8217;t tolerate the attacks (e.g. &#8220;uneducated&#8221;, &#8220;junior programmers&#8221;, etc.)</p>
      <p>
			<small>comment at <a href="#comment-631" title="">21. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-632">
			<p class="who"><cite><a href='http://naeblis.cx/rtomayko/' rel='external ' title='69.168.180.186'>Ryan Tomayko</a></cite>:</p>
			<p>Aristotle said:</p>
<blockquote>
<p>(Overall, I have to say I am very disappointed with<br />
  the direction the material on lesscode.org has been taking.)</p>
</blockquote>
<p>Email me for an account (rtomayko@gmail.com). I&#8217;d love to have you posting here if you can free up some time. I&#8217;d rather some of your comments be posts with more exposure anyway and I&#8217;ve been reading your blog for some time now with delight.</p>
      <p>
			<small>comment at <a href="#comment-632" title="">21. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-634">
			<p class="who"><cite><a href='http://bitdiddle.blogspot.com' rel='external ' title='66.30.55.254'>Bob Dionne</a></cite>:</p>
			<p>This is a wonderful thread, a classic one, that I enjoy reading every time it comes up. It sometimes devovles into tag team wrestling but that only speaks to our passions as programmers. I think Ryan&#8217;s comments, about languages that we build IDEs and guis around to make life easier, is very accurate. Part of this stems from the economics of software development. Bill de hOra wrote a wonderful piece on this topic some time ago, <a href="http://www.dehora.net/journal/2004/04/better_is_better_improving_productivity_through_programming_languages.html">Better is Better</a> that elaborates on this. </p>
<p>I think the terms software development and software factories are horribly misguided. I&#8217;m not criticizing it in terms of what it does for the workplace, there are good arguments for the use of all this, .e.g. UML pictures seems to have utility in communicating to managers that work is being done and these also help the logging industry ( sorry Ryan I just couldn&#8217;t resist :) I&#8217;m critical in that I think it&#8217;s flawed from the standpoint of programming and computer science.</p>
<p>I come down on the side of programming as craft. Incidentally this is not new. <a href="http://www.onlamp.com/pub/a/onlamp/2005/06/30/artofprog.html">Progamming as craft</a> and/or art is the topic of Don Knuth&#8217;s turing award address. It&#8217;s a good read. As Aristotle, Glyph and others have remarked the building of &#8220;jargon&#8221; and DSLs is important for reducing the complexity of large programs by creating layers of abstraction. This is most eloquently put by Paul Graham in his book On Lisp. Of course Lisp, being beautiful, is the best language for this. </p>
<p>In some sense the use of UML is tied to OOP which itself has been perhaps too successful as a programming paradigm as it has fostered the illusion that we can model reality with objects. Perhaps the original post referred to has it backwards. A programming language doesn&#8217;t model a CPU. The CPU executes the code of a machine language, just as a JVM or CLR executes bytecode. A programming language has syntax and semantics, though it a task of researchers to work out semantics. But the semantics are the model. For instance venn diagrams and truth tables help us model classical logics, the model being a boolean algebra. The machines that run programs verify that the statements of the program are true in the model. As a simple example, if I write x + y = y + x we all think of that as true, but of course that&#8217;s only so with respect to real numbers, integers rationals and so forth. It&#8217;s not true everywhere, only in structures where + commutes. For a programmer this is silly statement but to a mathematician x = x + 1 is downright absurd. As was commented on above abstraction works well in declarative systems like mathematics but when we throw in time and state it gets ugly. This creates the tension between imperative and functional languages. In my opinion when syntax and semantics are close to one another better languages emerge.</p>
<p>Sorry for the digression, the point being that languages have syntax and semantics and between the programmer writing a J2EE app and the CPU there are many, many languages, all the way down, each with it&#8217;s own syntax/semantics, and at the bottom you have this accursed boolean algebra of zeros and ones which can&#8217;t even deal with real numbers without a boat load of software. The fact that it all works still really amazes me though as Glyph points out what we are trying to do in software is even more complex. Truth is not two valued in the real world, if it were programming would be a piece of cake.</p>
<p>Not to be too harsh or blunt, I think boxology is very useful when used in small groups of programmers collaborating to help understand how to carve up the tasks for the day. Pictures on the whiteboard work very well. I believe it was Minsky who said that programming is the best medicine for sloppy ideas. Let the cleaning folks always erase the board at the end of the day. Go off and write the pieces of code, integrate them and test, come back the next day and draw the picture again and see if it looks the same. If so then you might be on to something. Infrastructure has never been better in terms of refactoring IDEs and so forth but in many ways it&#8217;s all been around for many years. Documentation is only useful when it&#8217;s part of the code and done well. Code generation is very hard, especially for compilers. To do it at the application level and do it well requires simple syntax, imho, which is why Lisp macros work. </p>
<p>Visual approaches work well when a DSL is already in place, .e.g. Lego Minstorms, or Excel. </p>
<p>In the beginning was the cons  </p>
<p>p.s. I&#8217;m writing this using this new Flock browser, it&#8217;s neat!</p>
      <p>
			<small>comment at <a href="#comment-634" title="">21. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-636">
			<p class="who"><cite>Bob</cite>:</p>
			<blockquote>
<p>How many of you have actually used AutoCAD or any CAD tool for that matter? Did you know that CAD stands for Computer Assisted Design? The keyword being design, which is what this entire discussion of modeling and code generation is about, but completely lost on all of you.</p>
</blockquote>
<p>I think Mitch is only focusing on one aspect of CAD systems, which is that they provide a medium for engineers to express product design, with the designs created being then able to guide manufacture. The obvious point to make here is that physical realization of a design is generally rather trivial. (If you&#8217;re aiming at mass production and realization isn&#8217;t trivial, then that&#8217;s a design flaw.) In programming, realization of a design is rarely trivial in quite this way: either its completely automatic - in which case &#8220;designing&#8221; is in reality programming - or it isn&#8217;t - in which case you&#8217;ll most likely run into trouble if you think of it as unskilled grunt-work.</p>
<p>But CAD systems do more than merely allowing designs to be created. The CAD file is a digital model of the eventual product, and can be used in verifying the design. The point of modelling is to identify issues prior to manufacture (and use). Trivially, if a design has solid components intersecting - physically impossible - this can be determined through their geometry. The outline of a car design can have a one-off realization in clay that can be used in wind-tunnel tests. Obviously there are more examples, but the point is that particular sorts of model can be used to give real information about the final product well before it exists.</p>
<p>In software this sort of thing is more rare. There are cases: a user-interface for a non-existant application can be faked up in order to see how usable it might be. But generally, in software engineering, &#8220;designs&#8221; and &#8220;models&#8221; tend to indicate pious hopes rather than anything more directly useful; and implementational issues generally only become apparent in, uh, the implementation.</p>
<p>[Incidentally, I work as a software engineer for a CAD company.]</p>
      <p>
			<small>comment at <a href="#comment-636" title="">21. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-645">
			<p class="who"><cite><a href='http://www.phppatterns.com' rel='external ' title='195.129.34.43'>Harry Fuecks</a></cite>:</p>
			<blockquote>
<p>I know we have had issues in the past with CASE tools and with earlier versions of UML and other code generation tools. But, I have software developers that I have worked with that won’t even give it a thought – they immediately get out their favorite source code editor and start writing code - so much for design.</p>
</blockquote>
<p>I haven&#8217;t read Mitch&#8217;s book list and I&#8217;m basically just a <a href="http://koranteng.blogspot.com/2005/05/get-on-bus.html">glue layer</a> guy but the only value I&#8217;ve ever found in UML is for documentation, and even then, sparsely used with disclaimers that it should not be trusted as an up to date API reference.</p>
<p>The main issue is I don&#8217;t find them useful to help design - it&#8217;s a theory / practice thing. Given a dynamic language I can put together a prototype of what I&#8217;m trying to do faster than I can draw it. In building the prototype, I&#8217;m confronted with real issues which need to be factored in e.g. specific error condition handling or quirks in a data structure. Time spent working on a theoretical model is time wasted in my state of mind.</p>
<p>In theory I can see the point for CASE tools for when designing &#8220;big systems&#8221; but in practice I don&#8217;t believe in &#8220;big systems&#8221;, just many small parts who&#8217;s interactions evolve over time.</p>
<p>That said, right now I&#8217;m half convinced by BPEL: been seeing stuff done with Tibco while checking out ActiveGrid on the side. Even so, the sceptical side tells me nice as it may be, there&#8217;s a bunch of specific concerns related to the systems involved in any given business process which will nullify any benefits of the of a pointy clicky high level view. There&#8217;s some smart remark here I can&#8217;t find the words for but something like &#8220;software project success is governed by specifics not generalizations&#8221; - in a way, exactly the point you make about adding paths in VS.</p>
<p>At the extreme end, what if the whole notion of &#8220;software industrialization&#8221; is bogus? That requirements and current conditions will always be one step ahead of design and that, apart from foundation libraries, code is either work in progress or about to die. That we&#8217;re missing the point of that word &#8220;soft&#8221;?</p>
<p>An alternative angle might be that software should be doable by anyone rather than just engineers, as Sam Ruby argues in <a href="http://www.intertwingly.net/blog/2005/10/20/Homesteaders-of-the-21st-Century">Homesteaders of the 21st Century</a></p>
<blockquote>
<p>we need to enable a future where everybody can be a switchboard operator.</p>
</blockquote>
      <p>
			<small>comment at <a href="#comment-645" title="">23. October 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-723">
			<p class="who"><cite>TonyB</cite>:</p>
			<p>Text has many advantages, as Ryan Tomayko has noted.  One good example is that the EDA (Electronic Design Automation) industry has moved from visual modeling (e.g. schematics) to text (Verilog, VHDL).</p>
<p>Or for GUI&#8217;s, graphical designers (like VB&#8217;s) aren&#8217;t always the best.  They can lead to a lot of fiddling for forms that change often.  For example, database-driven text program created GUI screens can be big time savers.</p>
<p>And I wonder if anyone here has worked in a manufacturing environment.  AutoCAD is not a modeling program, it&#8217;s a drafting program.  The mechanical design world seems to be going to domain-specific programs, with 2-D programs still used for some things (e.g. road layout), specialized 3-D programs for architecture, 3-D solid modelers (SolidWorks, Solid Edge, Inventor, Pro/E, NX, etc) for designing machines.  The 3-D solid modelers are a big improvement over AutoCAD, but still really don&#8217;t model the machine.</p>
<p>And going from a 3-D solid model to manufacturing, translating to CNC isn&#8217;t automatic; it&#8217;s still commmon to use 2-D prints as the intermediate step.  Even if a part is to be machined, there are often various ways to make it.  And there are many other methods that can be used.</p>
<p>Once the machine is made and put together, then there is debugging and fixing the problems.  Oh, and specifications&#8211;well, the lack of good specifications from the customer&#8211;are typically a big problem.</p>
<p>So electrical and mechanical analogies aren&#8217;t very good for software.  I think higher-level, mostly text-based languages, are the way forward.  But software will always be hard, just as chip design is hard (hmm, chip designs are often late, masks have to be re-spun, and sometimes the chip is scapped.  Just like software projects failing, but probably not as common).</p>
      <p>
			<small>comment at <a href="#comment-723" title="">02. November 2005</a> </small>
						</p>

		</li>

	
	
		<li class="alt" id="comment-787">
			<p class="who"><cite>robert</cite>:</p>
			<p>(parachuting in while looking for MDA threads):</p>
<p>naysayers have a look at codefutures.com.  not exactly UML, nor MDA, but what i&#8217;ve referred to as DDD, Database Driven Development (they don&#8217;t).  for those of us in the &#8220;usual&#8221; application development world, learning what Dr. Codd had to say, and riding it to its ultimate conclusion (the data is the model), can be enlightening.</p>
<p>or think of it this way:  all the data needed to guarantee its mutual integrity can either be in the datastore, or scattered as hardcode in your programs.  olde folk, who learned before Dr. Codd did his work, and java kiddies who think that XML is modern (it isn&#8217;t; it&#8217;s just an amateur IMS) both like to ignore this reality.<br />
as to the UI, generator rules can make that look anyway which doesn&#8217;t violate data constraints: html, css, javascript, AJAX.  the View is separate from the Model, yes??  with DDD, the Model is also the Control,  cute.</p>
<p>while there are XML driven generators galore which are based on user views, the systems that come out are based on naive data structures (usually just files mapped from the screens images), Flat File City.</p>
<p>takeaway&#8211;&gt; there is a better way, and while that better way may vary across humans, it will always be founded in the integrity constraints supported by the RM.  code is emitted solely to provide some UI which provides update.  start with a solid data model approach, and the rest comes out in the wash.  it has to.</p>
      <p>
			<small>comment at <a href="#comment-787" title="">01. December 2005</a> </small>
						</p>

		</li>

	
	        
	</ol>

 


<h3 id="respond">Leave a Reply</h3>


<form action="http://lesscode.org/wp-comments-post.php" method="post" id="commentform">


<p>
  <small>
    <strong>Note:</strong> None of this information is required but 
    leaving a Name and URL is much appreciated. You can also <a href="/wp-register.php">register</a>
    to have this stuff remembered.
  </small>
</p>

<p><input type="text" name="author" id="author" value="" size="22" tabindex="1" />
<label for="author"><small>Name </small></label></p>

<p><input type="text" name="email" id="email" value="" size="22" tabindex="2" />
<label for="email"><small>Mail (will not be published) </small></label></p>

<p><input type="text" name="url" id="url" value="" size="22" tabindex="3" />
<label for="url"><small>Website</small></label></p>


<div id="ajax-comment-preview" style="padding: .4em 0; color: #666; margin-top: 1em; border-top: 1px solid #ddd; border-bottom: 1px solid #ddd">Your comment can be previewed here.</div>

<p>
  <br />
  <small>
    <strong><a href="http://daringfireball.net/projects/markdown/syntax"
       title="Markdown Syntax Reference">Markdown</a>:</strong> 
    use the force, Luke.
  </small>
</p>

<p>
  <textarea name="comment" id="comment" cols="100%" rows="10" tabindex="4"></textarea>
</p>

<p>
  <input name="submit" type="submit" id="submit" tabindex="5" value="Submit Comment" />
<input type="hidden" name="comment_post_ID" value="100" />
</p>
<input name="preview" type="button" id="preview" tabindex="6" value="Preview" /><div id="ajax-comment-preview"></div>
</form>



	
	</div>


<div id="footer">
	<p style="float: left;">
		feeds: 
    <a href="http://lesscode.org/feed/atom/" title="Atom 0.3 feed for all posts">
      posts</a> (<a href="http://feedvalidator.org/check.cgi?url=http://lesscode.org/feed/atom/">valid?</a>)
    or <a href="http://lesscode.org/comments/feed/" title="RSS 2.0 feed for comments">comments</a>
       (<a href="http://feedvalidator.org/check.cgi?url=http://lesscode.org/comments/feed/">valid?</a>)
    <br />
		design by <a href="http://blog.ratterobert.com/">ratter / robert</a><br />
		powered by <a href="http://wordpress.org">WordPress</a>.<a href="http://wordpress.de">de</a><br />
	</p>
		<a name="search"><form method="get" id="searchform" action="/index.php">
<div><input type="text" value="" name="s" id="s" />
<input type="submit" id="searchsubmit" value="Search" />
</div>
</form>
</a>
</div>
<div id="switcher">
	<center>
			</center>
</div>
</div>
		</body>
</html>

<!-- Dynamic Page Served (once) in 0.572 seconds -->
