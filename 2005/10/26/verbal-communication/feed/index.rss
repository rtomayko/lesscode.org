<?xml version="1.0" encoding="UTF-8"?><!-- generator="wordpress/2.0.1" -->
<rss version="2.0" 
	xmlns:content="http://purl.org/rss/1.0/modules/content/">
<channel>
	<title>Comments on: Verbal Communication</title>
	<link>http://lesscode.org/2005/10/26/verbal-communication/</link>
	<description>AAaaaaahhhhrrrrrrr!</description>
	<pubDate>Mon, 17 Sep 2007 09:11:35 +0000</pubDate>
	<generator>http://wordpress.org/?v=2.0.1</generator>

	<item>
		<title>by: Anonymous</title>
		<link>http://lesscode.org/2005/10/26/verbal-communication/#comment-727</link>
		<pubDate>Thu, 03 Nov 2005 05:40:00 +0000</pubDate>
		<guid>http://lesscode.org/2005/10/26/verbal-communication/#comment-727</guid>
					<description>&lt;p&gt;&quot;Exactly. That’s why all the good books worth reading are not longer than two-three pages.&quot;&lt;/p&gt;

&lt;p&gt;So you're writing a book here, or trying to convey meaning?  &lt;/p&gt;

&lt;p&gt;Like Einstein said : &quot;If you can't explain something simply, you don't understand it well.&quot;&lt;/p&gt;

&lt;p&gt;It would clarify your arguments if you cut out the excessive leaky abstractions and didn't use so many strawmen.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>&#8220;Exactly. That’s why all the good books worth reading are not longer than two-three pages.&#8221;</p>
<p>So you&#8217;re writing a book here, or trying to convey meaning?  </p>
<p>Like Einstein said : &#8220;If you can&#8217;t explain something simply, you don&#8217;t understand it well.&#8221;</p>
<p>It would clarify your arguments if you cut out the excessive leaky abstractions and didn&#8217;t use so many strawmen.</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Alex Bunardzic</title>
		<link>http://lesscode.org/2005/10/26/verbal-communication/#comment-712</link>
		<pubDate>Mon, 31 Oct 2005 17:46:32 +0000</pubDate>
		<guid>http://lesscode.org/2005/10/26/verbal-communication/#comment-712</guid>
					<description>&lt;p&gt;Bob wrote:&lt;/p&gt;

&lt;blockquote&gt;The were probably many reasons for the intertia regarding 2 digit years, but one that Alex overlooks is data entry. If dates are always given with 2 digit years, that reduces the motivation for storing them otherwise. It’s odd that Alex misses this, since a possible implication of his comment about dates is that they should be stored in the form they were given by the user.&lt;/blockquote&gt;

&lt;p&gt;That's a valid point. End-user convenience is a decisive factor, of course, and typing 2-digit years instead of 4-digit is a major issue, no doubt about it.&lt;/p&gt;

&lt;p&gt;However, there is absolutely no reason why we can't have our cake and eat it too -- we can retain the end-user convenience (i.e. ask them to type only 2-digits for year), while prepending the supplied year behind the scene with the appropriate leading digits (there are algorhitms, based on the system clock, that can do that for us). Then the year would be stored properly, with all four digits, and any future confusion would thus be easily avoided.&lt;/p&gt;

&lt;p&gt;I also agree with your critique that I've allowed sloppiness to enter my argument when I muddled static-vs-dynamic with strong-vs-weak typing. Excellent points, and thanks for the clarification!&lt;/p&gt;

&lt;p&gt;But my basic argument remains -- languages should bend more toward human propensity to view information as text. Despite the fact that underlying machinery only understands 1s and 0s, it is its duty to present a legible face to the human users (in this case, programmers). In that regard, static languages are very unfriendly, actually they are quite rude.&lt;/p&gt;

&lt;p&gt;Dynamic languages fare better when it comes to letting us express ourselves in textual format by lowering the noise and amplifying the signal.&lt;/p&gt;

&lt;blockquote&gt;I won’t mount any defence of relational databases: but it makes more sense to me to dislike them for forcing all structure into a tabular straight-jacket than for having types for columns. All I can say is that if you’re using an RDBMS as a fairly dumb persistence engine, it’s probably best to be aware that this is what you are doing.&lt;/blockquote&gt;

&lt;p&gt;You're again absolutely right. The long ingrained propensity to offload a lot of legwork to an RDBMS must be held in check.&lt;/p&gt;

&lt;p&gt;The issue with tabular data representation is not necessarily that it is a straight-jacket constraint. What is more problematic is the normalization of the tabular representation. Humans tend to like viewing information in a tabular format, but are totally confused when this tabular format gets broken down into a cluster of tables.&lt;/p&gt;

&lt;p&gt;If we compare OLTP systems with OLAPs, the first thing we'll notice is that business analysis gravitates toward denormalizing OLTP tables, and ending up with one giant spreadsheet.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>Bob wrote:</p>
<blockquote><p>The were probably many reasons for the intertia regarding 2 digit years, but one that Alex overlooks is data entry. If dates are always given with 2 digit years, that reduces the motivation for storing them otherwise. It’s odd that Alex misses this, since a possible implication of his comment about dates is that they should be stored in the form they were given by the user.</p></blockquote>
<p>That&#8217;s a valid point. End-user convenience is a decisive factor, of course, and typing 2-digit years instead of 4-digit is a major issue, no doubt about it.</p>
<p>However, there is absolutely no reason why we can&#8217;t have our cake and eat it too &#8212; we can retain the end-user convenience (i.e. ask them to type only 2-digits for year), while prepending the supplied year behind the scene with the appropriate leading digits (there are algorhitms, based on the system clock, that can do that for us). Then the year would be stored properly, with all four digits, and any future confusion would thus be easily avoided.</p>
<p>I also agree with your critique that I&#8217;ve allowed sloppiness to enter my argument when I muddled static-vs-dynamic with strong-vs-weak typing. Excellent points, and thanks for the clarification!</p>
<p>But my basic argument remains &#8212; languages should bend more toward human propensity to view information as text. Despite the fact that underlying machinery only understands 1s and 0s, it is its duty to present a legible face to the human users (in this case, programmers). In that regard, static languages are very unfriendly, actually they are quite rude.</p>
<p>Dynamic languages fare better when it comes to letting us express ourselves in textual format by lowering the noise and amplifying the signal.</p>
<blockquote><p>I won’t mount any defence of relational databases: but it makes more sense to me to dislike them for forcing all structure into a tabular straight-jacket than for having types for columns. All I can say is that if you’re using an RDBMS as a fairly dumb persistence engine, it’s probably best to be aware that this is what you are doing.</p></blockquote>
<p>You&#8217;re again absolutely right. The long ingrained propensity to offload a lot of legwork to an RDBMS must be held in check.</p>
<p>The issue with tabular data representation is not necessarily that it is a straight-jacket constraint. What is more problematic is the normalization of the tabular representation. Humans tend to like viewing information in a tabular format, but are totally confused when this tabular format gets broken down into a cluster of tables.</p>
<p>If we compare OLTP systems with OLAPs, the first thing we&#8217;ll notice is that business analysis gravitates toward denormalizing OLTP tables, and ending up with one giant spreadsheet.</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Aristotle Pagaltzis</title>
		<link>http://lesscode.org/2005/10/26/verbal-communication/#comment-710</link>
		<pubDate>Mon, 31 Oct 2005 07:39:03 +0000</pubDate>
		<guid>http://lesscode.org/2005/10/26/verbal-communication/#comment-710</guid>
					<description>&lt;p&gt;&lt;a href=&quot;#comment-707&quot; rel=&quot;nofollow&quot;&gt;Bob&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Perhaps Alex intends to say that a good language can have various aggregate types (like arrays and hashes) but should only have one basic type: string. This, of course is the case with Perl. Contrast:&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;$ perl -e '$two = &quot;2&quot;; print $two * $two, &quot;\n&quot;'
   4&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Actually, Perl has several basic types, and they're strongly typed.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ perl -le'$a = []; print $a-&amp;#62;{foo}'
Can't coerce array into hash at -e line 1.
$ perl -le'$a = {}; print $a-&amp;#62;[0]'
Not an ARRAY reference at -e line 1.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;There are also a couple more types---but absolutely, positively no way you can turn one of them into another.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p><a href="#comment-707">Bob</a>:</p>
<blockquote>
<p>Perhaps Alex intends to say that a good language can have various aggregate types (like arrays and hashes) but should only have one basic type: string. This, of course is the case with Perl. Contrast:</p>
<p><code>$ perl -e '$two = "2"; print $two * $two, "\n"'<br />
   4</code></p>
</blockquote>
<p>Actually, Perl has several basic types, and they&#8217;re strongly typed.</p>
<p><code>$ perl -le'$a = []; print $a-&gt;{foo}'<br />
Can't coerce array into hash at -e line 1.<br />
$ perl -le'$a = {}; print $a-&gt;[0]'<br />
Not an ARRAY reference at -e line 1.</code></p>
<p>There are also a couple more types&#8212;but absolutely, positively no way you can turn one of them into another.</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Bob</title>
		<link>http://lesscode.org/2005/10/26/verbal-communication/#comment-707</link>
		<pubDate>Mon, 31 Oct 2005 00:39:45 +0000</pubDate>
		<guid>http://lesscode.org/2005/10/26/verbal-communication/#comment-707</guid>
					<description>&lt;p&gt;Misc Nitpicks:&lt;/p&gt;

&lt;p&gt;Binary coded decimal isn't a particularly compact representation for numbers. It is more admittedly more compact that representing each digit as an ASCII (or EBCDIC) character. But the real motivation for using BCD - right down to the machine level - was in order to simplify the routines needed for the conversions between the computer and human representations. Disk (and tape) storage may have been a scarce resource, but core memory came at a much higher premium.&lt;/p&gt;

&lt;p&gt;The were probably many reasons for the intertia regarding 2 digit years, but one that Alex overlooks is data entry. If dates are always given with 2 digit years, that reduces the motivation for storing them otherwise. It's odd that Alex misses this, since a possible implication of his comment about dates is that they should be stored in the form they were given by the user.&lt;/p&gt;

&lt;p&gt;Here's an oldie but a goodie: Alex is getting the strong-vs-weak typing mixed up with static-vs-dynamic typing. Ruby is strongly typed. From the fact that Alex recommeds its use - rather than that of, say, Forth or BCPL - it is evident that he likes using a strongly typed language. Perhaps Alex intends to say that a good language can have various aggregate types (like arrays and hashes) but should only have one basic type: string. This, of course is the case with Perl. Contrast:&lt;/p&gt;

&lt;p&gt;$ perl -e '$two = &quot;2&quot;; print $two * $two, &quot;\n&quot;'
4&lt;/p&gt;

&lt;p&gt;with:&lt;/p&gt;

&lt;p&gt;$ ruby -e 'two = &quot;2&quot;; puts two * two'
-e:1:in `*': can't convert String into Integer (TypeError)
from -e:1&lt;/p&gt;

&lt;p&gt;It also isn't very accurate to suggest that there's a necessay fit between dynamically-typed languages and the use of plain text. There is a long-standing tradition in Lisp and Smalltalk of using saving memory images to disk. The emphasis on using plain text wherever possible is a UNIXism.&lt;/p&gt;

&lt;p&gt;The reason for other &quot;dynamic&quot; languages being good with text is that they grew up in a UNIX-influenced world. More specifically, these languages, either directly or via Perl, show the influence of AWK. They are good with text because, whatever else they might be, they have to be &quot;better AWK&quot;. But AWK isn't the primary language of UNIX: C is. And C is statically typed. AWK was created because of the heavy use of text in UNIX; not the other way around.&lt;/p&gt;

&lt;p&gt;[As an aside, given that Java's remit was to be &quot;easy C++&quot; it's not that surprising that it's not so hot on this score, eg taking 20 lines (or whatever) to open a file and read it line-by-line. But that's a problem with the libraries, not the language &lt;em&gt;per se&lt;/em&gt;.]&lt;/p&gt;

&lt;p&gt;I won't mount any defence of relational databases: but it makes more sense to me to dislike them for forcing all structure into a tabular straight-jacket than for having types for columns. All I can say is that if you're using an RDBMS as a fairly dumb persistence engine, it's probably best to be aware that this is what you are doing.&lt;/p&gt;

&lt;p&gt;Lastly, it is odd to praise XML - given the context - not least because XML is plain text for such small values of &quot;plain&quot;.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>Misc Nitpicks:</p>
<p>Binary coded decimal isn&#8217;t a particularly compact representation for numbers. It is more admittedly more compact that representing each digit as an ASCII (or EBCDIC) character. But the real motivation for using BCD - right down to the machine level - was in order to simplify the routines needed for the conversions between the computer and human representations. Disk (and tape) storage may have been a scarce resource, but core memory came at a much higher premium.</p>
<p>The were probably many reasons for the intertia regarding 2 digit years, but one that Alex overlooks is data entry. If dates are always given with 2 digit years, that reduces the motivation for storing them otherwise. It&#8217;s odd that Alex misses this, since a possible implication of his comment about dates is that they should be stored in the form they were given by the user.</p>
<p>Here&#8217;s an oldie but a goodie: Alex is getting the strong-vs-weak typing mixed up with static-vs-dynamic typing. Ruby is strongly typed. From the fact that Alex recommeds its use - rather than that of, say, Forth or BCPL - it is evident that he likes using a strongly typed language. Perhaps Alex intends to say that a good language can have various aggregate types (like arrays and hashes) but should only have one basic type: string. This, of course is the case with Perl. Contrast:</p>
<p>$ perl -e &#8216;$two = &#8220;2&#8243;; print $two * $two, &#8220;\n&#8221;&#8216;<br />
4</p>
<p>with:</p>
<p>$ ruby -e &#8216;two = &#8220;2&#8243;; puts two * two&#8217;<br />
-e:1:in `*&#8217;: can&#8217;t convert String into Integer (TypeError)<br />
from -e:1</p>
<p>It also isn&#8217;t very accurate to suggest that there&#8217;s a necessay fit between dynamically-typed languages and the use of plain text. There is a long-standing tradition in Lisp and Smalltalk of using saving memory images to disk. The emphasis on using plain text wherever possible is a UNIXism.</p>
<p>The reason for other &#8220;dynamic&#8221; languages being good with text is that they grew up in a UNIX-influenced world. More specifically, these languages, either directly or via Perl, show the influence of AWK. They are good with text because, whatever else they might be, they have to be &#8220;better AWK&#8221;. But AWK isn&#8217;t the primary language of UNIX: C is. And C is statically typed. AWK was created because of the heavy use of text in UNIX; not the other way around.</p>
<p>[As an aside, given that Java&#8217;s remit was to be &#8220;easy C++&#8221; it&#8217;s not that surprising that it&#8217;s not so hot on this score, eg taking 20 lines (or whatever) to open a file and read it line-by-line. But that&#8217;s a problem with the libraries, not the language <em>per se</em>.]</p>
<p>I won&#8217;t mount any defence of relational databases: but it makes more sense to me to dislike them for forcing all structure into a tabular straight-jacket than for having types for columns. All I can say is that if you&#8217;re using an RDBMS as a fairly dumb persistence engine, it&#8217;s probably best to be aware that this is what you are doing.</p>
<p>Lastly, it is odd to praise XML - given the context - not least because XML is plain text for such small values of &#8220;plain&#8221;.</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Alex Bunardzic</title>
		<link>http://lesscode.org/2005/10/26/verbal-communication/#comment-703</link>
		<pubDate>Sun, 30 Oct 2005 03:46:34 +0000</pubDate>
		<guid>http://lesscode.org/2005/10/26/verbal-communication/#comment-703</guid>
					<description>&lt;p&gt;Aristotle Pagaltzis:&lt;/p&gt;

&lt;blockquote&gt;Being wordy and longwinded is no virtue.&lt;/blockquote&gt;

&lt;p&gt;Exactly. That's why all the good books worth reading are not longer than two-three pages.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>Aristotle Pagaltzis:</p>
<blockquote><p>Being wordy and longwinded is no virtue.</p></blockquote>
<p>Exactly. That&#8217;s why all the good books worth reading are not longer than two-three pages.</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Aristotle Pagaltzis</title>
		<link>http://lesscode.org/2005/10/26/verbal-communication/#comment-694</link>
		<pubDate>Fri, 28 Oct 2005 08:47:26 +0000</pubDate>
		<guid>http://lesscode.org/2005/10/26/verbal-communication/#comment-694</guid>
					<description>&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;How about ‘lesswords’?&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;I don’t subscribe to that philosophy. To me, ‘less mass’ applies only to technology, not to other forms of communication (like, I wouldn’t go for ‘less music’, ‘less art’, ‘less poetry’, etc.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Being wordy and longwinded is no virtue.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<blockquote>
<blockquote>
<p>How about ‘lesswords’?</p>
</blockquote>
<p>I don’t subscribe to that philosophy. To me, ‘less mass’ applies only to technology, not to other forms of communication (like, I wouldn’t go for ‘less music’, ‘less art’, ‘less poetry’, etc.)</p>
</blockquote>
<p>Being wordy and longwinded is no virtue.</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Alex Bunardzic</title>
		<link>http://lesscode.org/2005/10/26/verbal-communication/#comment-691</link>
		<pubDate>Thu, 27 Oct 2005 20:01:58 +0000</pubDate>
		<guid>http://lesscode.org/2005/10/26/verbal-communication/#comment-691</guid>
					<description>&lt;blockquote&gt;You don’t describe what or how Ruby on Rails does its derivative processing of text data…&lt;/blockquote&gt;

&lt;p&gt;Some details just posted &lt;a href=&quot;http://jooto.com/blog/index.php/2005/10/27/ultra-late-binding/&quot; rel=&quot;nofollow&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<blockquote><p>You don’t describe what or how Ruby on Rails does its derivative processing of text data…</p></blockquote>
<p>Some details just posted <a href="http://jooto.com/blog/index.php/2005/10/27/ultra-late-binding/">here</a>.</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Alex Bunardzic</title>
		<link>http://lesscode.org/2005/10/26/verbal-communication/#comment-689</link>
		<pubDate>Thu, 27 Oct 2005 16:30:39 +0000</pubDate>
		<guid>http://lesscode.org/2005/10/26/verbal-communication/#comment-689</guid>
					<description>&lt;p&gt;hxa wrote:&lt;/p&gt;

&lt;blockquote&gt;How about ‘lesswords’?&lt;/blockquote&gt;

&lt;p&gt;Sorry, I don't subscribe to that philosophy. To me, 'less mass' applies only to technology, not to other forms of communication (like, I wouldn't go for 'less music', 'less art', 'less poetry', etc.)&lt;/p&gt;

&lt;blockquote&gt;*Why* things are like that is irrelevant. Just say how they should be.&lt;/blockquote&gt;

&lt;p&gt;There is genesis to it, and it would be foolish to ignore it, lest we repeat our mistakes.&lt;/p&gt;

&lt;blockquote&gt;But what about dates, addresses, card numbers? Is no *treatment* of those needed?&lt;/blockquote&gt;

&lt;p&gt;Dates etc. &lt;em&gt;must&lt;/em&gt; be treated as special cases of text. Human mind treats them that way when parsing text, so  human mind's servant (i.e. software) must do the same. But database is not the right place for that kind of a treatment. Historically (and for the reasons I've discussed in my post), we've ended up painting ourselves in the corner by marrying certain products (i.e. RDBMSs), but now's the time for the divorce.&lt;/p&gt;

&lt;blockquote&gt;You don’t describe what or how Ruby on Rails does its derivative processing of text data…&lt;/blockquote&gt;

&lt;p&gt;I'm working on a followup article where I need to introduce the concepts that Ruby uses in order to act as a smart servant that would do the appropriate parsing.&lt;/p&gt;

&lt;p&gt;Stay tuned (and thanks for your very useful comments!)&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>hxa wrote:</p>
<blockquote><p>How about ‘lesswords’?</p></blockquote>
<p>Sorry, I don&#8217;t subscribe to that philosophy. To me, &#8216;less mass&#8217; applies only to technology, not to other forms of communication (like, I wouldn&#8217;t go for &#8216;less music&#8217;, &#8216;less art&#8217;, &#8216;less poetry&#8217;, etc.)</p>
<blockquote><p>*Why* things are like that is irrelevant. Just say how they should be.</p></blockquote>
<p>There is genesis to it, and it would be foolish to ignore it, lest we repeat our mistakes.</p>
<blockquote><p>But what about dates, addresses, card numbers? Is no *treatment* of those needed?</p></blockquote>
<p>Dates etc. <em>must</em> be treated as special cases of text. Human mind treats them that way when parsing text, so  human mind&#8217;s servant (i.e. software) must do the same. But database is not the right place for that kind of a treatment. Historically (and for the reasons I&#8217;ve discussed in my post), we&#8217;ve ended up painting ourselves in the corner by marrying certain products (i.e. RDBMSs), but now&#8217;s the time for the divorce.</p>
<blockquote><p>You don’t describe what or how Ruby on Rails does its derivative processing of text data…</p></blockquote>
<p>I&#8217;m working on a followup article where I need to introduce the concepts that Ruby uses in order to act as a smart servant that would do the appropriate parsing.</p>
<p>Stay tuned (and thanks for your very useful comments!)</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: hxa</title>
		<link>http://lesscode.org/2005/10/26/verbal-communication/#comment-688</link>
		<pubDate>Thu, 27 Oct 2005 15:05:04 +0000</pubDate>
		<guid>http://lesscode.org/2005/10/26/verbal-communication/#comment-688</guid>
					<description>&lt;p&gt;How about 'lesswords'? -- Delete the first three sections and get to the point straight away. Forget the circumstantial inferences about storage size. &lt;em&gt;Why&lt;/em&gt; things are like that is irrelevant. Just say how they should be.&lt;/p&gt;

&lt;p&gt;The point is an interesting and appropriate one: Data entered as text can mostly be stored unprocessed as text. All type enforcement or relational conversion is redundant and wasted effort.&lt;/p&gt;

&lt;p&gt;But what about dates, addresses, card numbers? Is no &lt;em&gt;treatment&lt;/em&gt; of those needed?&lt;/p&gt;

&lt;p&gt;You don't describe what or how Ruby on Rails does its derivative processing of text data...&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>How about &#8216;lesswords&#8217;? &#8212; Delete the first three sections and get to the point straight away. Forget the circumstantial inferences about storage size. <em>Why</em> things are like that is irrelevant. Just say how they should be.</p>
<p>The point is an interesting and appropriate one: Data entered as text can mostly be stored unprocessed as text. All type enforcement or relational conversion is redundant and wasted effort.</p>
<p>But what about dates, addresses, card numbers? Is no <em>treatment</em> of those needed?</p>
<p>You don&#8217;t describe what or how Ruby on Rails does its derivative processing of text data&#8230;</p>
]]></content:encoded>
				</item>
</channel>
</rss>

<!-- Dynamic Page Served (once) in 0.386 seconds -->
<!-- Cached page served by WP-Cache -->
