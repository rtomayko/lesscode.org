<?xml version="1.0" encoding="UTF-8"?><!-- generator="wordpress/2.0.1" -->
<rss version="2.0" 
	xmlns:content="http://purl.org/rss/1.0/modules/content/">
<channel>
	<title>Comments on: The Myth Of Data Integrity</title>
	<link>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/</link>
	<description>AAaaaaahhhhrrrrrrr!</description>
	<pubDate>Mon, 17 Sep 2007 09:11:32 +0000</pubDate>
	<generator>http://wordpress.org/?v=2.0.1</generator>

	<item>
		<title>by: Kragen Sitaker</title>
		<link>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-749</link>
		<pubDate>Tue, 15 Nov 2005 05:11:16 +0000</pubDate>
		<guid>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-749</guid>
					<description>&lt;p&gt;Ben Finney writes: &lt;/p&gt;

&lt;blockquote&gt;that’s four options, not three :-)&lt;/blockquote&gt;

Oops, you're right --- thanks :)

&lt;blockquote&gt;
You make the point that the application code need to know about the constraint; that’s only true in that the application needs to deal with the case when the constraint is violated. But why not pass the actual enforcement off to the RDBMS, and have the application just deal with how to handle that result?
&lt;/blockquote&gt;

&lt;p&gt;The three, um, four alternatives I outlined are different ways to have the application deal with how to handle that result; in other words, they are the choices available as &quot;recovery actions&quot; to the programmer.  I argued that each of them is unacceptable for software intended for end-users (that is, someone not conversant with the underlying database schema).  Is there a better alternative I haven't thought of, or do you think that one of those four choices is acceptable in that context?&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>Ben Finney writes: </p>
<blockquote><p>that’s four options, not three :-)</p></blockquote>
<p>Oops, you&#8217;re right &#8212; thanks :)</p>
<blockquote><p>
You make the point that the application code need to know about the constraint; that’s only true in that the application needs to deal with the case when the constraint is violated. But why not pass the actual enforcement off to the RDBMS, and have the application just deal with how to handle that result?
</p></blockquote>
<p>The three, um, four alternatives I outlined are different ways to have the application deal with how to handle that result; in other words, they are the choices available as &#8220;recovery actions&#8221; to the programmer.  I argued that each of them is unacceptable for software intended for end-users (that is, someone not conversant with the underlying database schema).  Is there a better alternative I haven&#8217;t thought of, or do you think that one of those four choices is acceptable in that context?</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Ben Finney</title>
		<link>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-733</link>
		<pubDate>Fri, 04 Nov 2005 01:50:11 +0000</pubDate>
		<guid>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-733</guid>
					<description>&lt;p&gt;&lt;a href=&quot;#comment-725&quot; rel=&quot;nofollow&quot;&gt;Kragen&lt;/a&gt; wrote:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you try to delete some row that a foreign key constraint requires to exist, and the
  database stops you, your application code has three choices. It can display the
  database’s error message to the user; it can pretend that the transaction succeeded; it
  can retry (not that this is a good idea, but I’ve seen it done); or it can display a
  content-free “general failure” message.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Two problems:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;that's four options, not three :-)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;you've missed (at least) one viable option.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The code should be aware that the transaction can fail, but let the RDBMS do the job of &lt;em&gt;enforcing&lt;/em&gt; the data integrity. If the transation succeeds, fine! The application hasn't had to do any checking before that happens, and it can continue on with the rest of the job. If the transaction fails, the code knows immediately, and can then proceed with whatever recovery action the programmer deems necessary.&lt;/p&gt;

&lt;p&gt;You make the point that the application code need to know about the constraint; that's only true in that the application needs to deal with the case when the constraint is violated. But why not pass the actual &lt;em&gt;enforcement&lt;/em&gt; off to the RDBMS, and have the application just deal with how to handle that result?&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p><a href="#comment-725">Kragen</a> wrote:</p>
<blockquote>
<p>If you try to delete some row that a foreign key constraint requires to exist, and the<br />
  database stops you, your application code has three choices. It can display the<br />
  database’s error message to the user; it can pretend that the transaction succeeded; it<br />
  can retry (not that this is a good idea, but I’ve seen it done); or it can display a<br />
  content-free “general failure” message.</p>
</blockquote>
<p>Two problems:</p>
<ul>
<li>
<p>that&#8217;s four options, not three :-)</p>
</li>
<li>
<p>you&#8217;ve missed (at least) one viable option.</p>
</li>
</ul>
<p>The code should be aware that the transaction can fail, but let the RDBMS do the job of <em>enforcing</em> the data integrity. If the transation succeeds, fine! The application hasn&#8217;t had to do any checking before that happens, and it can continue on with the rest of the job. If the transaction fails, the code knows immediately, and can then proceed with whatever recovery action the programmer deems necessary.</p>
<p>You make the point that the application code need to know about the constraint; that&#8217;s only true in that the application needs to deal with the case when the constraint is violated. But why not pass the actual <em>enforcement</em> off to the RDBMS, and have the application just deal with how to handle that result?</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Alex Bunardzic</title>
		<link>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-732</link>
		<pubDate>Thu, 03 Nov 2005 21:00:16 +0000</pubDate>
		<guid>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-732</guid>
					<description>&lt;p&gt;Not to clog the lesscode's bandwidth, I have posted some of the responses to the criticisms here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jooto.com/blog/index.php/2005/11/03/more-on-data-integrity/&quot; rel=&quot;nofollow&quot;&gt;More on data integrity&lt;/a&gt;&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>Not to clog the lesscode&#8217;s bandwidth, I have posted some of the responses to the criticisms here:</p>
<p><a href="http://jooto.com/blog/index.php/2005/11/03/more-on-data-integrity/">More on data integrity</a></p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Kragen Sitaker</title>
		<link>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-726</link>
		<pubDate>Thu, 03 Nov 2005 04:38:00 +0000</pubDate>
		<guid>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-726</guid>
					<description>&lt;p&gt;I guess I should point out that RDBMSes make the best object stores I've had the chance to use, even though that isn't really what they're designed for.  I haven't had the opportunity to use persistence software that's really designed for object-reference graphs that does even a fraction of what MySQL 2.0 did.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>I guess I should point out that RDBMSes make the best object stores I&#8217;ve had the chance to use, even though that isn&#8217;t really what they&#8217;re designed for.  I haven&#8217;t had the opportunity to use persistence software that&#8217;s really designed for object-reference graphs that does even a fraction of what MySQL 2.0 did.</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Kragen Sitaker</title>
		<link>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-725</link>
		<pubDate>Thu, 03 Nov 2005 04:24:30 +0000</pubDate>
		<guid>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-725</guid>
					<description>&lt;p&gt;Alex's article isn't controversial.  It's just stupid.  He's grasping at an understanding of some things other people have said, and missing.&lt;/p&gt;

&lt;p&gt;Here's what &lt;b&gt;I&lt;/b&gt; think of constraints in the database, based on a scant few years of experience building a small number of database-backed web apps.  I promise not to use any stupid similes.&lt;/p&gt;

&lt;p&gt;If there's some validity constraint in the database that's not reflected in your application code, you still lose.  If you try to delete some row that a foreign key constraint requires to exist, and the database stops you, your application code has three choices.  It can display the database's error message to the user; it can pretend that the transaction succeeded; it can retry (not that this is a good idea, but I've seen it done); or it can display a content-free &quot;general failure&quot; message.&lt;/p&gt;

&lt;p&gt;Assuming your application's users don't understand the underlying table structure and the RDBMSese in which the error message is phrased, none of these four options are acceptable.  So putting validity constraints in the database doesn't save you from also putting them in your code.  (If there's only one possible way a particular statement can fail, then you can catch the failure and turn it into an appropriate error message or change in behavior; but that still requires putting the knowledge of the data integrity constraint in your application code.)&lt;/p&gt;

&lt;p&gt;Now we have a maintenance problem: two copies of the constraint, in very different forms, that must be modified in parallel.  This is a heavy cost, but that's not the end of it; putting your constraints in the database has three other major drawbacks.&lt;/p&gt;

&lt;p&gt;Checking the correctness of an update can be done (and must be done, as explained above) in application code, which can be distributed across a large number of front-end machines if your application has to scale.  If you check the correctness of the update again in the database, it will cost you a great deal more money to scale to larger numbers of users, and you will hit a much lower ceiling.&lt;/p&gt;

&lt;p&gt;Database integrity constraints are difficult to check in and out of a source control system, unless your &quot;build process&quot; involves reinitializing with an empty database.  This leads to spending a lot of time looking for phantom bugs when your development database has a stale constraint, or lacks one that will exist on the production machine.&lt;/p&gt;

&lt;p&gt;Finally, database integrity constraints tend to cause problems with things like backup and restore.  It's true that if they are correctly implemented (both the constraints and the backup/restore process) then no such problems will arise.  In the real world, though, it is often a real problem.&lt;/p&gt;

&lt;p&gt;Fundamentally the issue is that relational databases are being deployed as application-internal object stores mediated by object-relational mappers.  Both relational databases and object stores are fine things, but they have very different design requirements.  A relational database is intended to be interacted with directly some of the time; SQL is a carefully designed user interface for this purpose.  It's designed to serve as a shared data store among several different applications, some of which may be written in COBOL and thus have very definite ideas about how long certain strings should be.  An object store is intended to hide inside a program and be easy to refactor.  (I'm leaving aside the issue of the relational data model and the object-reference-graph model, which is important, but not as important.)  &lt;/p&gt;

&lt;p&gt;Many useful features of relational databases, such as multi-column primary keys, string length limits, triggers, foreign key constraints, users and their associated permissions, and so forth, are simply not useful when the database is being deployed as an internal object store for some application.&lt;/p&gt;

&lt;p&gt;That's the story behind the real &quot;agile people don't like database integrity constraints&quot; issue.&lt;/p&gt;

&lt;p&gt;I've spent a few years developing software with XP, and I don't appreciate being lumped in with clueless seekers of controversy like Alex Bunardzic.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>Alex&#8217;s article isn&#8217;t controversial.  It&#8217;s just stupid.  He&#8217;s grasping at an understanding of some things other people have said, and missing.</p>
<p>Here&#8217;s what <b>I</b> think of constraints in the database, based on a scant few years of experience building a small number of database-backed web apps.  I promise not to use any stupid similes.</p>
<p>If there&#8217;s some validity constraint in the database that&#8217;s not reflected in your application code, you still lose.  If you try to delete some row that a foreign key constraint requires to exist, and the database stops you, your application code has three choices.  It can display the database&#8217;s error message to the user; it can pretend that the transaction succeeded; it can retry (not that this is a good idea, but I&#8217;ve seen it done); or it can display a content-free &#8220;general failure&#8221; message.</p>
<p>Assuming your application&#8217;s users don&#8217;t understand the underlying table structure and the RDBMSese in which the error message is phrased, none of these four options are acceptable.  So putting validity constraints in the database doesn&#8217;t save you from also putting them in your code.  (If there&#8217;s only one possible way a particular statement can fail, then you can catch the failure and turn it into an appropriate error message or change in behavior; but that still requires putting the knowledge of the data integrity constraint in your application code.)</p>
<p>Now we have a maintenance problem: two copies of the constraint, in very different forms, that must be modified in parallel.  This is a heavy cost, but that&#8217;s not the end of it; putting your constraints in the database has three other major drawbacks.</p>
<p>Checking the correctness of an update can be done (and must be done, as explained above) in application code, which can be distributed across a large number of front-end machines if your application has to scale.  If you check the correctness of the update again in the database, it will cost you a great deal more money to scale to larger numbers of users, and you will hit a much lower ceiling.</p>
<p>Database integrity constraints are difficult to check in and out of a source control system, unless your &#8220;build process&#8221; involves reinitializing with an empty database.  This leads to spending a lot of time looking for phantom bugs when your development database has a stale constraint, or lacks one that will exist on the production machine.</p>
<p>Finally, database integrity constraints tend to cause problems with things like backup and restore.  It&#8217;s true that if they are correctly implemented (both the constraints and the backup/restore process) then no such problems will arise.  In the real world, though, it is often a real problem.</p>
<p>Fundamentally the issue is that relational databases are being deployed as application-internal object stores mediated by object-relational mappers.  Both relational databases and object stores are fine things, but they have very different design requirements.  A relational database is intended to be interacted with directly some of the time; SQL is a carefully designed user interface for this purpose.  It&#8217;s designed to serve as a shared data store among several different applications, some of which may be written in COBOL and thus have very definite ideas about how long certain strings should be.  An object store is intended to hide inside a program and be easy to refactor.  (I&#8217;m leaving aside the issue of the relational data model and the object-reference-graph model, which is important, but not as important.)  </p>
<p>Many useful features of relational databases, such as multi-column primary keys, string length limits, triggers, foreign key constraints, users and their associated permissions, and so forth, are simply not useful when the database is being deployed as an internal object store for some application.</p>
<p>That&#8217;s the story behind the real &#8220;agile people don&#8217;t like database integrity constraints&#8221; issue.</p>
<p>I&#8217;ve spent a few years developing software with XP, and I don&#8217;t appreciate being lumped in with clueless seekers of controversy like Alex Bunardzic.</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Anonymous</title>
		<link>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-720</link>
		<pubDate>Wed, 02 Nov 2005 13:21:12 +0000</pubDate>
		<guid>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-720</guid>
					<description>&lt;p&gt;I'm realling getting fed up of these nonsensical and unsubstantiated articles from the Agile Methodologies front.  Everyday someone jumps on the bandwagon, spurts a random blog entry and maybe enjoys being &quot;controversial&quot; after having been debunked by 99% of the readers.&lt;/p&gt;

&lt;p&gt;What would you do if someone claims that the earth is flat, and starts becoming famous thanks to his &quot;controversial&quot; theories?  You may demonstrate his claims to be false, or just ignore him.  By choosing the first option, the risk is to feed the debate and his fame as well.&lt;/p&gt;

&lt;p&gt;I think that I'll ignore these people, starting from now.  They will happily drown in their &quot;agile&quot; mud when their methodologies will collide with real-world non-trivial development problems.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>I&#8217;m realling getting fed up of these nonsensical and unsubstantiated articles from the Agile Methodologies front.  Everyday someone jumps on the bandwagon, spurts a random blog entry and maybe enjoys being &#8220;controversial&#8221; after having been debunked by 99% of the readers.</p>
<p>What would you do if someone claims that the earth is flat, and starts becoming famous thanks to his &#8220;controversial&#8221; theories?  You may demonstrate his claims to be false, or just ignore him.  By choosing the first option, the risk is to feed the debate and his fame as well.</p>
<p>I think that I&#8217;ll ignore these people, starting from now.  They will happily drown in their &#8220;agile&#8221; mud when their methodologies will collide with real-world non-trivial development problems.</p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Daniel</title>
		<link>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-719</link>
		<pubDate>Wed, 02 Nov 2005 04:51:49 +0000</pubDate>
		<guid>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-719</guid>
					<description>&lt;p&gt;Alex Bunardzic wrote an article on database integrity in which he completely dismissed commonly accepted methods of using an RDBMS to enforce data integrity. I strongly disagree with his conclusions. In fact, I think his arguments are terrible.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.openpolitics.com/pieces/archives/001768.html&quot; rel=&quot;nofollow&quot;&gt;Continue reading...&lt;/a&gt;&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>Alex Bunardzic wrote an article on database integrity in which he completely dismissed commonly accepted methods of using an RDBMS to enforce data integrity. I strongly disagree with his conclusions. In fact, I think his arguments are terrible.</p>
<p><a href="http://www.openpolitics.com/pieces/archives/001768.html">Continue reading&#8230;</a></p>
]]></content:encoded>
				</item>
	<item>
		<title>by: Anonymous</title>
		<link>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-718</link>
		<pubDate>Tue, 01 Nov 2005 17:24:35 +0000</pubDate>
		<guid>http://lesscode.org/2005/11/01/the-myth-of-data-integrity/#comment-718</guid>
					<description>&lt;p&gt;So... wrong.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>So&#8230; wrong.</p>
]]></content:encoded>
				</item>
</channel>
</rss>

<!-- Dynamic Page Served (once) in 0.345 seconds -->
<!-- Cached page served by WP-Cache -->
